<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html
 xmlns="http://www.w3.org/1999/xhtml"
 xmlns:epub="http://www.idpf.org/2007/ops"
 xml:lang="ja"
 class="hltr"
>
<head>
<meta charset="UTF-8"/>
<title>第35章 アスペクト指向</title>
<link rel="stylesheet" type="text/css" href="../../style/book-style.css"/>
</head>
<body epub:type="bodymatter">
<!-- Navigation -->
<h1>Matz Essays Volume 2</h1>
<p class="navigation-top"><a href="../../index.xhtml">HOME</a>　&gt;　<a href="../index.xhtml">Volume 2</a>　&gt;　<a href="p-010.xhtml">第35章</a>　&gt;　Ruby開発日記</p>
<!-- Body -->
<section id="chap3508" class="level2">
<a id="page_059"/>
<h3>◆ Ruby開発日記 ◆ ごみ集め</h3>
<hr class="hr-green" />
<p class="in">私は子供のときから片付けるのが苦手で、両親と住んでいた頃は自分の机の上にはいつも山のようにものが積み上がっていました。こんな机では勉強できないので、教科書、参考書、ノートなど必要なものを山の中からピックアップして、兄弟の机を借りて勉強したこともあります。</p>
<p class="in">学生時代、一人暮らしのときもひどいものでした。自分の部屋は散らかし放題で、とても客は呼べない状態でした。きちんと片付けることができる人のことはいつも尊敬しています。</p>
<p class="in">さて、プログラミングの世界でも片付けは発生します。オブジェクト指向プログラミングではどんどんオブジェクトを作り出すのですが、用事が終わって不要になったオブジェクトは「ごみ」になってしまいます。これをそのままにしておくと、メモリ不足で性能が落ちたり、他のプロセスに迷惑をかけたりします。</p>
<p class="in">CやC++であれば使い終わった「オブジェクト」は自分で片付ける必要があります。Cでは<code>free</code>関数を使ってメモリ領域を解放しますし、C++なら<code>delete</code>を使います。自分で散らかしたものは自分で片付けよう、というわけですね。大変行儀が良いやり方だと思います。しかし、私のように生来片付けるのが苦手な人は、オブジェクトの後片付けを忘れたり、うっかりまだ使っているものを捨ててしまったりして、面倒なことを引き起こしてしまいます。このようなメモリ関係の間違いは、問題が発生する場所と原因が一致しないことが多く、大変見つけにいバグになります。</p>
<p class="in">だいたいそんな細々としたことは人間がわざわざするべきではないのです。そこで、不要になったと判断されたオブジェクトを自動的に片付けてくれる機能のことを「ごみ集め」あるいは「ガベージコレクション（garbage collection）」といいます。「GC」と省略して呼ぶこともあります。</p>
<p class="in">Javaに採用されて広く知られるようになったGCですが、最初にGCを採用したのはLispというプログラミング言語で、それは実に今から40年以上前のことです。それ以来、実に長い間研究が続けられてきた分野なのです。GCを使えばCやC++でしばしば悩まされるメモリ関係の問題から完全に解放されて、プログラムの信頼性ははるかに向上します。加えて最近ではGC技術も進歩しているので、手動でメモリ管理した場合に比べて性能の面でも遜色ないケースが多いという報告もあります。</p>
<p class="in">そのGCのやり方ですが、コンピュータには人間の意図はわからないので、あるオブジェクトをもうこの先二度と使わないかどうかは自動的には判定できません。ですから、ごみかどうか判定するのには違ったやり方を使います。</p>
<p class="in">机の上にいろいろなものが乗っている状態を想像してみてください。それらのものは互いに複雑に関連しあっていて、ひと目では捨ててよいものだか悪いものだかわかりません。あなたの仕事はこの中からごみを見つけ出し、捨ててよいということになります。</p>
<p class="in">まず最初にやることは明らかに必要なものを選び出すことです。GCではこれらの「もの」のことを「ルート（root）」と呼びます。ルートのオブジェクトと直接あるいは間接的に関連している「もの」はいつか参照される可能性があるので捨ててはいけません。逆にいうとルートと関連を持たないものは将来参照される可能性がゼロですから、捨ててはいけません。</p>
<p class="in">GCの手法の1つmark and sweep法では、まずルートから始めて関連を持つオブジェクト全部に印（mark）を付けていきます。この印が付いているものは捨ててはいけないものと判断されます。関連のあるオブジェクト全部に印を付けた後は、机の上のもの全部を順番に眺めて印が付いていないものを捨ててしまいます。印が付いているものの中には将来二度と使われないものもあるかもしれませんが、それでもかまいません。</p>
<a id="page_060"/>
<p class="in">mark and sweep法では、まず「使用中」のオブジェクト全部に印を付けてから、すべてのオブジェクトのうち印の付いてないものを選び出しますから、ごみ集めにかかる時間は現在使用中のオブジェクトの数と、現在存在するすべてのオブジェクトの数に比例します。</p>
<p class="in">別の手法copy法では、もう1つ別の机を用意して、ルートオブジェクトを移してしまいます。またルートと関連のあるものも次々と移していきます。関連のあるものをすべて移動させた後、元の机の上にはごみしか残っていないというわけです。元の机に残ったものは一気に捨てることができます。空いた机は次回のごみ集めのときにまた使います。2つの机を使うとはぜいたくな方法ですが、ごみ集めにかかる時間が「生きている」オブジェクトの数だけに比例することがうれしいケースもあります。</p>
<p class="in">mark and sweep法にしても、copy法にしても生きているオブジェクトの数が増えればごみ集めの時間が長くなってしまうことには変わりありません。ごみ集めというのはいわば無駄な時間ですから短ければ短いほどよいわけで、そのために作業が中断したりしては本末転倒です。そこでいろいろな方法が考えられています。たとえば、あるオブジェクトがいくつのオブジェクトから参照されているかいつも管理しておくreference count法、机をいくつかの領域に区切って、頻繁に使う領域は頻繁に片付けるgenerational法などがあります。これらにはそれぞれに長所と短所がありますので、必要に応じて組み合わせたり、切り替えたりして使われています。</p>
<p class="in">最近の言語にはほとんど何らかの形のごみ集め機能があります。Javaもそうですし、もちろんRubyにもあります。Perl, Python, PHP, Lispなどなど。ないのはCやC++, Fortran, Pascalなど古い言語ばかりです。</p>
<p class="in">あなたのプログラムが実行中にたくさんのオブジェクトを作り出すときに、その背後ではごみ集め機能ががんばっていて、使われなくなったオブジェクトを人知れず回収して、メモリ領域をリサイクルしているのです。あなたのプログラムがうまく動いたとき、ガベージコレクタのことをちょっとだけ思い出してくださいね。そうすれば私も苦労して実装したことが報われるというものです。</p>
<p class="in">現実世界の話に戻ると、結婚して私の部屋の状態は以前よりもずいぶんマシにはなったのですが、私と私の遺伝子を受け継いだ子供たちがどんどん散らかしてくれるので、妻がどんなに整頓しても、いつまでたっても部屋は片付きません。どうか私のうちを訪問するときには、あらかじめ片付けてからお迎えできるように前もって連絡してくださいね（苦笑）。</p>
</section>
<!-- Navigation -->
<br /><br />
<hr />
<p class="navigation-right"><a href="p-010.xhtml">&lt;&lt; 前ページ</a>　<a href="p-012.xhtml">次ページ &gt;&gt;</a></p>
</body>
</html>
