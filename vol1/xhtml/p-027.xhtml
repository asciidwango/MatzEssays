<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html
 xmlns="http://www.w3.org/1999/xhtml"
 xmlns:epub="http://www.idpf.org/2007/ops"
 xml:lang="ja"
 class="hltr"
>
<head>
<meta charset="UTF-8"/>
<title>第12章 パターンマッチ</title>
<link rel="stylesheet" type="text/css" href="../../style/book-style.css"/>
</head>
<body epub:type="bodymatter">
<!-- Navigation -->
<h1>Matz Essays Volume 1</h1>
<p class="navigation-top"><a href="../../index.xhtml">HOME</a>　&gt;　<a href="../index.xhtml">Volume 1</a>　&gt;　<a href="p-025.xhtml">第12章</a>　&gt;　Ruby開発日記</p>
<!-- Body -->
<section id="chap1227" class="level2">
<h3>◆ Ruby開発日記 ◆ Riteと鬼車の話</h3>
<hr class="hr-green" />
<p class="in">実は先日とうとうRite の開発を始めました。Riteというのは、前にも話したような気がしますが、Ruby 2.0のコードネームです。1993年に0.01から始めて、1996年に1.0、そして現在1.6.8までリリースしたのですが（おや、そういえばまだ1.8.0が出ていませんね（苦笑））、だんだん問題が出てきました。</p>
<section id="chap122701" class="level3">
<h4>ソフトウェアの老化</h4>
<p class="in">皆さん当然ご存じのように、経年劣化によってだんだん傷んでくるハードウェアと違って、ソフトウェアはただ時間が経ったからといって壊れたりはしません。実際、ソフトウェアの寿命は思ったより長くて、たとえばしばらく前に話題になった2000年問題は、ソフトウェアが開発当時には当然リプレースされているだろうと思われた時期になっても生き残っていたことが原因の一部です。</p>
<p class="in">ところが、そういうソフトウェアでも老化するのです。ソフトウェアの老化の原因は大きく分けると以下の2つです。</p>
<div class="description">
<p class="ditem">環境の変化</p>
<p class="dni">時代の変化により、ソフトウェアが最初に仮定していた環境も変化してしまうとき、ソフトウェアは老化します。</p>
<a id="page_179"/>
<p class="ditem">複雑さの増加</p>
<p class="dni">ソフトウェアのメンテナンスに伴い、バグが修正されたり、機能が追加されたりします。それによりプログラムは複雑化し、次第に人間の脳では全容を把握できなくなってきます。人間が扱いきれない複雑なプログラムは老化したといえます。</p>
</div>
<p class="in">開発開始以来9年を経過したRubyは、典型的な後者の症状を呈しています。最初から全部の仕様がわかっていればよかったのでしょうが、少しずつ機能を追加して現在まできているので、あちこちがからまって非常に複雑です。いや、全部ではないんですが、何箇所か大変なところがあるんです。</p>
</section>
<section id="chap122702" class="level3">
<h4>そこでRite</h4>
<p class="in">いやあ、それもこれも私にもっと将来的な展望とか、プログラマーとしての才能とかがあればよかったのですが、そもそもない袖は振れません。</p>
<p class="in">そこで、長年かけてきて「Rubyとはなんぞや」ということがほぼ明らかになった現時点で、改めて再実装することによって老化を解消することを考えました。これがRuby 2.0、通称Riteです。</p>
<p class="in">全体を再実装することから、たぶんRuby 2.0は現在のRubyとはかなり変化することになると思います。それで、Riteという別の名前も用意したわけです。変化するとはいっても、現在存在する大量のRubyプログラムのうち99%くらいはそのまま動作するようにしようと思ってはいますが。</p>
<p class="in">まあ、とにかく開発を開始したわけです。で、どこから取り掛かろうかと考えた末、まずは正規表現ルーチンから始めようと考えました。正規表現ルーチンはRubyの中でも複雑すぎる（いわば老化した）箇所の1つです。</p>
</section>
<section id="chap122703" class="level3">
<h4>正規表現ルーチンの問題</h4>
<p class="in">現在のRubyの正規表現ルーチンはもともとはGNU Emacsに付属していたもので、それを谷本さんという方が（たしかjgawkのために）マルチバイト化され、それを私が大量に手を加えてPerl 5互換の正規表現を追加し、さらに、よしだむさんがUTF-8対応を追加したという代物です。とりあえず十分動いているのですが、少しだけ問題があります。</p>
<ul>
<li><p>機能追加を重ねて誰も細部を理解していない</p></li>
<li><p>よって、バグが発見されても、なかなか直せない</p></li>
<li><p>Rubyのソースの中で正規表現ルーチンだけLGPLでライセンスが違う</p></li>
</ul>
<p class="in">これらの問題を一気に解決するために、「いつかは正規表現ルーチンを書き換えよう」とずっと思っていたので、Riteにやる気になったこの機会に正規表現から取り掛かろうと考えました。もう1つの老化箇所であるインタプリタのコアの部分は、正規表現ルーチン以上に迷路のような構成になっていますから、それを避けたというものあるのですが。</p>
</section>
<section id="chap122704" class="level3">
<a id="page_180"/>
<h4>正規表現ルーチンの実装</h4>
<p class="in">とはいうものの、長い間「いつかやろう」と思いつつ、取り掛からなかったことにはそれなりに理由があったのです。実際に実装する段になって、自分がいかに正規表現について無知であるかについて思い知らされました。</p>
<p class="in">もともと正規表現は正則集合という比較的数学に近い概念から発生していることもあって、数学の能力に欠けている私には困難の極みです。</p>
</section>
<section id="chap122705" class="level3">
<h4>正規表現ルーチンの勝負</h4>
<p class="in">そんなこんなでぐずぐずしていたら、こっちは半分もできていないのに、ソフネックの小迫さんから「鬼車」なるコードネームの正規表現ルーチンがリリースされてしまいました。この鬼車は</p>
<ul>
<li><p>Rubyの正規表現互換</p></li>
<li><p>M17Nにも対応済み</p></li>
<li><p>いくつか直していなかったバグが存在しない</p></li>
<li><p>現在の正規表現ルーチンを置き換えるためのRubyへのパッチも提供されている</p></li>
<li><p>Rubyにはなかった（難しくて実装できなかった）look behindが実装されている</p></li>
</ul>
<p class="ni">などなどとてもかないません。素直に負けを宣言します。Riteの正規表現ルーチンはきっとこの「鬼車」ベースになるでしょう。いや、この完成度ならばもっと早く、1.8で置き換えることもできそうです。</p>
<p class="in">というわけで、出来かけの私の正規表現ルーチンは永遠に封印されることになりそうです。残念。とはいえ、これで懸案のLGPLの問題も解消され、私は楽しみを失った代わりに、苦労をしなくて済んだのでよかったと思うべきなんでしょう。</p>
<p class="in">しょうがないので、私は残るもう1つ、インタプリタコアに挑戦することにしましょう。こっちもぐずぐずしてたら、他の人に負けちゃうかもしれません。</p>
</section>
</section>
<!-- Navigation -->
<br /><br />
<hr />
<p class="navigation-right"><a href="p-026.xhtml">&lt;&lt; 前ページ</a>　<a href="p-028.xhtml">次ページ &gt;&gt;</a></p>
</body>
</html>
