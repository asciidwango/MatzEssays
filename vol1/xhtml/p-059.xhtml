<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html
 xmlns="http://www.w3.org/1999/xhtml"
 xmlns:epub="http://www.idpf.org/2007/ops"
 xml:lang="ja"
 class="hltr"
>
<head>
<meta charset="UTF-8"/>
<title>第27章 エクストリーム・プログラミング</title>
<link rel="stylesheet" type="text/css" href="../../style/book-style.css"/>
</head>
<body epub:type="bodymatter">
<!-- Navigation -->
<h1>Matz Essays Volume 1</h1>
<p class="navigation-top"><a href="../../index.xhtml">HOME</a>　&gt;　<a href="../index.xhtml">Volume 1</a>　&gt;　第27章</p>
<!-- Body -->
<section id="chap27" class="level1">
<a id="page_367"/>
<span class="chap-title">Matz Essay</span><span class="chap-num">27</span>
<hr class="chap-hr" />
<h2>
<span class="fontsmall">初等Ruby講座</span><br />
エクストリーム・プログラミング
</h2>
<hr class="chap-hr" />
<p class="right">[<span class="it">Linux magazine</span>, 2003年8月号]</p>
<div class="newlead">
<p class="ih">「エクストリーム・プログラミング」通称XPについて解説してます。20年前だとアジャイルという言葉はあっても、ソフトウェア開発フレームワークとしてのScrumはまだ誕生したばかりみたいですね。会社（ネットワーク応用通信研究所）でのXP実践の経験をまとめています。実際の経験をベースにしているので、アジャイル開発実践の記録として今でも価値のあると思います。記事中では、XPを適用したプロジェクトのリーダーの前田修吾さんにインタビューをしているのですが、彼はRubyのコミッターでもあり、頼もしい後輩です。2023年、彼はネットワーク応用通信研究所の社長に就任しました。すごい。</p>
<p class="ih">「Ruby開発日記」は、「10年後の技術者」と題して未来予測をしています。予想した10年後はとっくに過ぎていますが、予想された</p>
<ul>
<li><p>死ぬ技術もある</p></li>
<li><p>OS、ネットワーク、言語は大して変化しない</p></li>
<li><p>アスペクト指向が言語取り込まれているかも</p></li>
</ul>
<p class="ni">はほぼ当たっていると言えるでしょう。最後のアスペクト指向はすっかり聞かなくなりましたが、たとえばRubyに<code>Module#prepend</code>が取り込まれたように、見えない形でほそぼそと生き残っています。</p>
<p class="in">20年経っても、この傾向は変わっていないようです。</p>
</div>
<div class="lead">
<p class="ni">今月はRubyそのものではなく、Rubyを使った開発手法について学んでみましょう。今月取り上げるのは、最近話題のソフトウェア開発体制である「エクストリーム・プログラミング」です。</p>
</div>
<section id="chap2701" class="level2">
<a id="page_368"/>
<h3>XPとは何か?</h3>
<hr class="hr-gray" />
<p class="in">XPとはエクストリーム・プログラミングの略で、最近話題の開発手法、というよりも開発体制のことです。エクストリームとは「極限」「極端」という意味ですから「極端流プログラミング」とでも呼べばよいのでしょうか。</p>
<p class="in">XPでは過去のプログラミング経験でよいと呼ばれるものを極限まで推し進めたものです。</p>
<ul>
<li><p>コードレビューがよいのであればいつでもコードレビューを行う</p></li>
<li><p>テストがよいのであれば全員がいつでもテストを行う</p></li>
<li><p>設計がよいのであれば設計を日常の一部にする</p></li>
<li><p>シンプルがよいのであればシステムを最もシンプルな状態に保つ</p></li>
<li><p>アーキテクチャが重要であれば全員がいつでもアーキテクチャを定義し洗練する</p></li>
<li><p>結合テストが重要であれば、1日数回結合テストする</p></li>
<li><p>短いイテレーションがよいのであれば短い単位で行う</p></li>
</ul>
<p class="in">従来のプログラミングのやり方を経験している人にとっては、あまりに極端で「え?　いつでもコードレビューを行う?　そんなにムリ」とか、「いつでもテスト?　そんなにテストしてどうするの?」とか疑問がわきそうな内容です。</p>
<p class="in">しかし、XPを提唱したKent Beckは、一見無茶に聞こえるこれらが非常に有効であることを示したのです。</p>
</section>
<section id="chap2702" class="level2">
<h3>解決すべき問題</h3>
<hr class="hr-gray" />
<p class="in">私は長らく職業プログラマーでお客さまのためのプログラムを書いてきました。フリーソフトウェアの開発にかまけてきたため期間の割には経験豊富とはいえないのですが、それでも以下のような問題をいつも抱えていました。</p>
<ul>
<li><p>見積もりが当てにならない</p></li>
<li><p>ユーザーの要求がころころ変わる</p></li>
<li><p>バグが多すぎ、テストに時間がかかりすぎ</p></li>
<li><p>テストが不十分</p></li>
<li><p>システム完成後、ドキュメントを書くのが大変</p></li>
</ul>
<p class="in">こういう問題を抱えているのは私だけではないと思います。XPではこれらの問題は以下のようないくつかの間違った仮定のためではないかと考えます。</p>
<ul>
<li><p>ユーザーは自分のほしいものを最初から知っている</p></li>
<li><p>ドキュメントはシステムのあるべき姿を記述できている</p></li>
<li><p>変更はあとになればなるほどコストが高くなる</p></li>
<li><p>なんとか動作しているコードは修正すべきではない</p></li>
</ul>
<a id="page_369"/>
<p class="in">しかし、これらはある条件の下には真実でないかもしれないのです。私は最初にXPについて読んだとき、今まであきらめてきていた「常識」が不変のものではなかったことに気が付いてびっくりしました。</p>
</section>
<section id="chap2703" class="level2">
<h3>12のプラクティス</h3>
<hr class="hr-gray" />
<p class="in">あまりページ数に余裕がありませんし、XPのすごさについて手っ取り早く解説するために、概念的なことではなく、実際に何をやるとどんなよいことがあるかについてまず解説しましょう。</p>
<p class="in">XPには具体的な行動である「12のプラクティス（実践）」があります。最近新しいプラクティスが追加されたような話を聞きますが、ここではXPについて最初に解説した本である『XPエクストリーム・プログラミング入門』（ピアソン・エデュケーション、ISBN4-89471-275-X）にあげられているものを紹介します（<a href="#table2701">表27.1</a>）。</p>
<div class="table" id="table2701">
<p class="tbl-caption">表27.1●XPの12のプラクティス</p>
<table class="tbl01">
<tr>
<th><span class="k">プラクティス</span></th>
<th><span class="k">説明</span></th>
</tr>
<tr>
<td>計画ゲーム</td>
<td>柔軟に頻繁に計画を見直す</td>
</tr>
<tr>
<td>短期リリース</td>
<td>シンプルなシステムを素早く構築、たびたびリリースする</td>
</tr>
<tr>
<td>メタファ</td>
<td>比喩によるわかりやすいアーキテクチャを提示する</td>
</tr>
<tr>
<td>シンプルな設計</td>
<td>いつもシンプルに。複雑さは積極的に取り除く</td>
</tr>
<tr>
<td>テスティング</td>
<td>常にテストする。顧客は検収テストを書く</td>
</tr>
<tr>
<td>リファクタリング</td>
<td>システムの振る舞いを変えずに常にシステムを改善する</td>
</tr>
<tr>
<td>ペアプログラミング</td>
<td>いつも二人のプログラマーが1台のマシンコンピュータに向かう</td>
</tr>
<tr>
<td>共同所有</td>
<td>誰でもいつでもすべてのコードを変更できる</td>
</tr>
<tr>
<td>継続した結合</td>
<td>タスクが終了するごとに1日に何度も結合テストを行う</td>
</tr>
<tr>
<td>40時間労働</td>
<td>週40時間以上働かない。残業しない</td>
</tr>
<tr>
<td>オンサイトユーザー</td>
<td>顧客をチームに加え、いつでも質問に答えてもらう</td>
</tr>
<tr>
<td>コーディング規約</td>
<td>ルールに従ってコーディングする</td>
</tr>
</table>
</div>
<p class="in">こんなことができるのか、効果があるのか、と思われる方がいらっしゃるかもしれません。しかし、実際には正しく適用されれば、効果が出るのです。</p>
<p class="in">ここで断っておきますが、私自身はXPについて経験豊富というほどではありません。しかし、私のチームが最近のプロジェクトで実際にXPを行い見事な成果をあげつつあります。</p>
<p class="in">たとえば彼らはプロジェクトの言語としてRubyを選択し、Rubyの<code>test/unit</code>ライブラリを使って、自分たちが作るすべてのコードにテストプログラムを書きました。実際にプログラムを書く前にテストプログラムを書くのです（テスティング）。</p>
<p class="in">これによってテストプログラムがその機能に関する「動くドキュメント」になります。テストプログラムが正しく動いているということはプログラムにはバグがないということです、テストプログラムそのものに間違いがない限り。プログラムを書き加えるたび、修正を行うたびにテストプログラムが実行されます。プログラムが完成に近づくにつれて失敗するテスト項目が減っていくことになります（継続した結合）。</p>
<a id="page_370"/>
<p class="in">テストによってプログラムが期待どおり動作していることがいつでも確認できますから、プログラムの修正が恐くありません。よりシンプルになるように、より効率よくなるようにプログラムをリファクタリングしてもプログラムの正しさが保証されます（リファクタリング、シンプルな設計）。</p>
<p class="in">彼らはいつも二人一組で1台のコンピュータに向かってプログラミングします（ペアプログラミング）。一人がコードを書いている間、もう一人はたえずもっと高い視点からツッコミを行います。一人でコードを書いているときとは違った視点からのレビューが常に行われ、対話しながらプログラミングすることにより、見落としがちな点をより早く発見できるうえ、知識や情報の移転が素早く行われます。</p>
<p class="in">彼らの書いたコードはすべてCVSに格納されます。リポジトリが共有されているので、問題がある部分を誰でもいつでも修正できます（コード共有）。</p>
<p class="in">チームの中には顧客から派遣されてきた技術者がいます。この技術者は開発すべきシステムに対する知識を教えてくれるだけでなく、一緒に開発することで、今後彼らがシステムを保守するときに必要な知識を学び、また私たちが開発していないシステムの他の部分との調整も行っています（オンサイトユーザー）。</p>
<p class="in">このシステムが稼働すべき日は外部的な要因から固定されています。しかし別の要因から開発開始は予定よりかなり遅れました。プロジェクトチームは優先順位を常に検討し、稼働日に要求される機能を重要な順から実装していきました（計画ゲーム）。開発が始まっても私たちが開発すべきシステムの全容が見えず、不安がありましたが、現在の予定では必要な機能はすべて期日までに完成しそうです。</p>
<p class="in">正直なところ40時間労働は完全には守られていません。しかし、残業は週数時間程度であまり過酷な状況にはなっていません。日常的に働きすぎているということはどこかに間違いがあるということであり、それはもっと早い時点で計画に反映され、解決される必要があります。徹夜続きで生産的な仕事ができるはずもないのです（40時間労働）。</p>
</section>
<section id="chap2704" class="level2">
<h3>4つのバリュー</h3>
<hr class="hr-gray" />
<p class="in">XPがこのようなプラクティスを導き出せたのは「4つのバリュー（価値）」を大切にしたからです。その4つとは、</p>
<ul>
<li><p>コミュニケーション</p></li>
<li><p>シンプル</p></li>
<li><p>フィードバック</p></li>
<li><p>勇気</p></li>
</ul>
<p class="ni">です。これらの裏付けがあるからこそ12のプラクティスが効果を発揮するのです。そして、それらのバリューの背後にはチームのメンバーがお互いにリスペクト（尊敬・尊重）する気持ちが期待されます。私の経験からも成功するチームあるいはコミュニティにはこのリスペクトの気持ちがあるように思われます。</p>
</section>
<section id="chap2705" class="level2">
<a id="page_371"/>
<h3>RubyとXP</h3>
<hr class="hr-gray" />
<p class="in">XPはある特定の言語に依存した手法ではありません。しかし、XPというのはもともとSmalltalkでの開発から生まれてきたやり方ですから、Smalltalkのような動的な言語のほうが向いているようです。</p>
<p class="in">そういう意味からはRubyはまさにXP向けの言語と呼べるでしょう。RubyはSmalltalkと同様に動的なオブジェクト指向言語ですし、クラスやメソッドをオブジェクトとして取り扱う機能もあります。また、Ruby 1.8からはユニットテストのフレームワークである<code>test/unit</code>ライブラリが標準添付されています。</p>
<p class="in"><code>test/unit</code>ライブラリの使用例を<a href="#list2701">リスト27.1</a>に示します。</p>
<div class="plistc" id="list2701">
<p class="lst-caption">リスト27.1●test/unit使用例</p>
<pre>require <span class="str">&#39;test/unit&#39;</span>

<span class="kwd">class</span> TC_MyTest &lt; Test::Unit::TestCase
  <span class="kwd">def</span> setup
    <span class="cmt"># テスト前の準備</span>
  <span class="kwd">end</span>
     
  <span class="kwd">def</span> teardown
    <span class="cmt"># テスト後の後片付け</span>
  <span class="kwd">end</span>
 
  <span class="kwd">def</span> test_foo
    <span class="cmt"># テストを行う。</span>
    <span class="cmt"># testで始まるメソッドがテストされる</span>
    assert(cond, <span class="str">&#39;Assertion was false.&#39;</span>)
    assert_equal(expect, actual, <span class="str">&#39;unexpected result.&#39;</span>)
  <span class="kwd">end</span>
<span class="kwd">end</span></pre>
<hr class="hr-gray" />
</div>
<p class="ih">“<code>setup</code>”や“<code>teardown</code>”メソッドはテスト前に実行されます（必要なければ定義しなくてもかまいません）。たとえばテストに用いるファイルの準備やデータベースの接続は<code>setup</code>メソッドで行い、それらの後始末を<code>teardown</code>メソッドで行います。必要な値をテストメソッド（メソッド名が<code>test</code>で始まるもの）に渡すためにはインスタンス変数を使うとよいでしょう。</p>
<p class="in">テストメソッドでは実際のテスト項目のために<code>assert</code>（表明）メソッドを使いますが、<code>assert</code>として用いることができるメソッドのうち主要なものを<a href="#table2702">表27.2</a>に示します。</p>
<div class="table" id="table2702">
<a id="page_372"/>
<p class="tbl-caption">表27.2●assertメソッド</p>
<table class="tbl01">
<tr>
<th><span class="k">メソッド</span></th>
<th><span class="k">説明</span></th>
</tr>
<tr>
<td><code>assert(値[,メッセージ])</code></td>
<td>値が真か</td>
</tr>
<tr>
<td><code>assert_equal(値1,値2[,メッセージ])</code></td>
<td>値が一致するか</td>
</tr>
<tr>
<td><code>assert_raises(例外[,メッセージ])...</code></td>
<td>ブロックが例外を出すか</td>
</tr>
<tr>
<td><code>assert_instance_of(クラス,値[,メッセージ])</code></td>
<td>クラスのインスタンスか</td>
</tr>
<tr>
<td><code>assert_kind_of(クラス[,メッセージ])</code></td>
<td>クラス（か子孫）のインスタンスか</td>
</tr>
<tr>
<td><code>assert_respond_to(obj,id[,メッセージ])</code></td>
<td><code>id</code>というメソッドを持つか</td>
</tr>
<tr>
<td><code>assert_nil(値[,メッセージ])</code></td>
<td><code>nil</code>か</td>
</tr>
</table>
</div>
<p class="in">テストメソッドの登録や明示的な呼び出しは必要ありません。このプログラムを実行するとテストメソッドを勝手に実行してくれます。実行結果は<a href="#list2702">リスト27.2</a>のようになります（「<code>.</code>」の数がテストの数になります）。</p>
<div class="plistc" id="list2702">
<p class="lst-caption">リスト27.2●test/unitの実行例</p>
<pre>Loaded suite /tmp/t
Started
..
Finished in 0.002082 seconds.</pre>
<hr class="hr-gray" />
</div>
</section>
<section id="chap2706" class="level2">
<h3>プロジェクトリーダーへのインタビュー</h3>
<hr class="hr-gray" />
<p class="in">では、今回のわが社の「XPプロジェクト」のリーダーである前田修吾さんにインタビューしてみましょう。ご存じのとおり、前田さんは<code>mod_ruby</code>や<code>eruby</code>の開発者でもあります。ちなみにこのプロジェクトでの私の立場は「オブザーバー」であり、プロジェクト全体を暖い目で見守る立場です。</p>
<p class="in">なお、このプロジェクトはまだ完了していない事例であり、守秘義務などの関係で具体的な内容には触れられないことをご容赦ください。</p>
<p><br /></p>
<p class="hang-interview"><span class="k">まつもと（以下「ま」）</span>：では、前田さん、このプロジェクトについていろいろお伺いしたいのですが、なぜXPを採用しようと思ったのですか?</p>
<p class="hang-interview"><span class="k">前田さん（以下「前」）</span>：はい、最大の理由は「やってみたかったから」ということです。XPという開発手法には前から関心がありましたから。しかし、もちろん理由はそれだけではありません。</p>
<p class="iin">まず、今回のシステム開発に対して私たちのところまで出向いて一緒に開発してくれるオンサイトユーザーが得られたこと、それからプロジェクト規模がちょうどよかったことが大きいです。あまり小さなプロジェクトではペアプログラミングなどによって生じる無駄を取り返せませんし、逆にあまり大きなプロジェクトではXPはうまくいかなそうです。</p>
<p class="iin">もう1つの理由はプロジェクトの「トラックナンバー」を大きくしたかったということです。「トラックナンバー」というのはそのプロジェクトの参加人数のうち何人がトラックにひかれても大丈夫かということを意味する数字ですね。トラックナンバーが1だと一人欠けただけでプロジェクトがストップすることを意味します。今回のプロジェクトではペアプログラミングによる知識共有などでトラックナンバーを2か3にできたと思います。</p>
<a id="page_373"/>
<p class="hang-interview"><span class="k">ま</span>：このプロジェクトについてさしつかえない範囲で聞かせてください。</p>
<p class="hang-interview"><span class="k">前</span>：あまり詳しいことは言えないのですが、このプロジェクトはある顧客のWebシステムの一部になります。三層アーキテクチャのデータベース層とビジネスロジック層が私たちの開発している部分です。プレゼンテーション層は別のチームがASP.NETを使って開発しています。この別チームの存在がこのプロジェクトの難しいところです。ビジネスロジック層とプレゼンテーション層はSOAPを使って情報をやりとりするようにしました。</p>
<p class="iin">現在、プロジェクトを開始して1カ月ですが、今までに13000行のRubyコードを書きました。テストを含めると3万行を超えます。最終的な規模はちょっと予想できないのですが、この倍を超えるかもしれません。</p>
<p class="hang-interview"><span class="k">ま</span>：3万行のRubyプログラムですか、私が今まで聞いた中でも最大規模ですね。それを1カ月で開発したというのはすごいですね。では、XPを実践する中で12のプラクティスをどのように使いましたか?　すべて実践しましたか?</p>
<p class="hang-interview"><span class="k">前</span>：いえ、全部のプラクティスは実践しませんでした。実践しなかったのは具体的には「短期リリース」「メタファ」「コーディング規約」ですね。あと、「40時間労働」もちょっとオーバーしていますね。だいたい毎日9時から7時までの45時間労働くらいでしょうか。今までで一度だけ土曜日に出勤しました。</p>
<p class="iin">今はまだプロジェクト開始して1カ月ですから「短期リリース」は無理だとか、チームメンバーのスタイルにあまりばらつきがなく「コーディング規約」があまり必要でなかったとかが実践しなかった理由ですね。「メタファ」については既存のシステム互換でそこに機能拡張をするということで、アーキテクチャ的に迷いがなかったので使いませんでした。</p>
<p class="iin">他のプラクティスはだいたい実践しました。ストーリーカードやタスクカード、CRCカードを用意して「計画ゲーム」を実践したり、ユニットテストを徹底したり。コードはCVSを使って共有しました。また、今回は顧客から二人の技術者をお借りし、こちらの技術者二人といつもペアを組むようにしました。</p>
<p class="iin">あと、ユニットテストコードがあると安心してコードの変更ができますね。途中で仕様変更とかデータベースのテーブル構成が変わったりしたのですが、比較的容易に対応できました。</p>
<p class="hang-interview"><span class="k">ま</span>：生産性から考えると非常に成功したケースと言えそうですね。今回のプロジェクトでXP以外に工夫した点がありますか。</p>
<p class="hang-interview"><span class="k">前</span>：そうですね、テストケースが非常に多いので、テストケースをYAMLの記述から自動生成したりしました。その他、まつもとさんが<a href="p-057.xhtml#chap26">先月号</a>で紹介したようなYAMLからの自動生成はあちこちで使いました。SOAP通信用のWSDL（WebService Description Language）もRubyを使ってYAMLから記述したんですよ。</p>
<p class="hang-interview"><span class="k">ま</span>：そうですか。で、XPの効果のほどは?</p>
<p class="hang-interview"><span class="k">前</span>：正直なところコードを書くスピードは一人でプログラムしたほうがずっと速いです。今回はRubyで開発していますし、もともと生産性はかなり高いのだと思います。やはりペアプログラミングではコミュニケーションのコストがあるので。しかし、ユニットテストのおかげでコードの信頼性は高まったと思います。</p>
<p class="iin">また、今回はオンサイトユーザーが得られたおかげで要求仕様と実装のギャップのずれの修正が素早く行えました。また、わからないことがあればユーザーに直接質問できますから、ドキュメントが少なくて済みました。というか、全然書いていません。</p>
<a id="page_374"/>
<p class="hang-interview"><span class="k">ま</span>：これまで1カ月間XPな生活を過ごしているわけですが、XP生活の印象は?</p>
<p class="hang-interview"><span class="k">前</span>：なんだか今までに比べると「仕事してるな」って感じがします。結局、朝9時から7時までびっちり仕事しています。メールをチェックする頻度もすっかり減ってしまいました。ペアプログラミングの効果かもしれません。最初は密度が高くてかなり疲れましたが、この1カ月でだいぶ慣れました。</p>
<p class="hang-interview"><span class="k">ま</span>：ありがとうございます。では最後に、またXPしたいと思いますか?</p>
<p class="hang-interview"><span class="k">前</span>：そうですね。プロジェクトの規模によっては行ってみたいと思います。3000行くらいのプロジェクトなら一人のほうが絶対速いですし。それからプロジェクトの予算によりますね。あまり小さな予算だと複数の開発者を割り振れませんから。それから、XPを行うためには顧客や会社の理解が前提だと思います。特にオンサイトユーザーについては顧客に理解してもらうのが難しいかもしれません。</p>
<p class="iin">あと、どの言語を使うかというのもありますね。Cとかじゃやりたくありません。JavaやC++でもやっぱりイヤですね。XPを行うときの言語はメタプログラミング機能を持っててほしいです。</p>
<p class="hang-interview"><span class="k">ま</span>：では、もう一人、今度はオンサイトユーザーとしてチームに参加されたYoshinoさん（ペンネーム）にもお伺いしましょう。</p>
<p class="hang-interview"><span class="k">ま</span>：Yoshinoさんは以前からRubyについてご存じでしたか?</p>
<p class="hang-interview"><span class="k">Yoshino（以下「Y」）</span>：使ったことはありませんでした。でも、Rubyという名前は知っていました。世界的に有名ですから。</p>
<p class="hang-interview"><span class="k">ま</span>：またまた。ほめても何も出ませんよ（笑）。今回、XPについて初めて聞かれたときにはどのように感じましたか?</p>
<p class="hang-interview"><span class="k">Y</span>：なんだか楽しそうだな、と思いました。今まで自社内で開発してましたが、今までやってきたやり方とは全然違いますし。また、いつも二人でプログラミングすると聞いてわくわくしました。</p>
<p class="hang-interview"><span class="k">ま</span>：では、1カ月経った今のXPに対する感想は?</p>
<p class="hang-interview"><span class="k">Y</span>：今回、仕様がはっきり決まっていない部分があって、そこの調整役が大変でした。最初、私は単なる開発者として参加したつもりだったのですが、実際には調整役の責任が大きくて。また、調整を行うときには、調整役が十分な権限を持たないといけないと思いました。</p>
<p class="iin">あと、情報を共有するのが大変だと感じることがありました。今回、プレゼンテーション層の開発が別チームなのでそことのやりとりに課題が残りましたね。</p>
<p class="iin">全体的には非常によい環境で刺激的な仕事ができたと思います。ペアプログラミングというやり方はユニークで面白いと思いました。後はペア間のレベルの違いをどう克服するかについて考えないといけないと思います。今回、私たちはRubyを全然知らなかったので。ペアプログラミングを通じてずいぶん学びましたが。</p>
<p class="hang-interview"><span class="k">ま</span>：また、XPしたいと思いますか?</p>
<p class="hang-interview"><span class="k">Y</span>：うーん、次はもっと若い人に経験してもらいたい、かな（笑）。でも、自分のところでもやってみたいとは思っています。たとえば新人教育用プロジェクトでやってみるとか。そのときにはペアプログラミングにおける役割分担についても考えてみたいです。あと、ユニットテストはすばらしいと思いました。これについてはぜひ今後もやっていきたいと思っています。</p>
<p class="iin">今回、初めてのことばかりで非常によい経験でした。すばらしい環境で仕事ができて光栄です。ありがたいです。</p>
<a id="page_375"/>
<p class="hang-interview"><span class="k">ま</span>：ほめても何も出ませんってば。お話を聞かせてくださって、こちらこそありがとうございます。</p>
</section>
<section id="chap2707" class="level2">
<h3>XPとオープソース開発</h3>
<hr class="hr-gray" />
<p class="in">私自身がXP開発経験が豊富というわけでもないのに、XPに肩入れをするのにはわけがあります。XPのバリューとプラクティスは、私が深く関わっているオープンソース開発と非常によく似ているのです。</p>
<p class="in">私たちはCVSなどを用いてコード共有します。ペアプログラミングは行いませんが、変更は多数の開発協力者が確認します。私たちはシンプルな実装を好み、しばしばリファクタリングを行います。私たちはメーリングリストを通じて実際のユーザーの意見に耳を傾けます。</p>
<p class="in">また、コミュニケーション、シンプル、フィードバック、勇気の4つのバリューとその背後にあるリスペクトの気持ちはオープンソース開発にも必要な原則です。</p>
<p class="in">結局、XPが注目されるのも、オープンソースが注目されるのも、それらが達成しようとしている柔軟性にも原因があるのかもしれません。</p>
<p class="in">XPを始めとする柔軟な開発手法を提唱している人々がAgile Manifest（Agileは「機敏な」という意味）という文書で顧客の価値と柔軟性を最重視する姿勢を宣言しましたが、その人々の中に<em>Programming Ruby</em>を書いたDaveThomasとAndy Huntがいたのは偶然ではないと思います。</p>
</section>
<section id="chap2708" class="level2">
<h3>まとめ</h3>
<hr class="hr-gray" />
<p class="in">ということで、今回はXPについて駆け足で解説しました。</p>
<p class="in">Rubyの開発にはまだ十分取り入れていないXPのプラクティスがあります。計画ゲームとか（完全な）ユニットテストとか。これらもRubyの開発に取り入れて、より信頼性の高いRubyを作ろうかな、なんてこの原稿を書きながら考えました。</p>
<p class="in">皆さんのXPを試してみませんか、できることから、一部だけでも。</p>
</section>
</section>
<!-- Navigation -->
<br /><br />
<hr />
<p class="navigation-right"><a href="p-058.xhtml">&lt;&lt; 前ページ</a>　<a href="p-060.xhtml">次ページ &gt;&gt;</a></p>
</body>
</html>
