<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html
 xmlns="http://www.w3.org/1999/xhtml"
 xmlns:epub="http://www.idpf.org/2007/ops"
 xml:lang="ja"
 class="hltr"
>
<head>
<meta charset="UTF-8"/>
<title>第1章 Rubyにみるスクリプト言語の実装技法</title>
<link rel="stylesheet" type="text/css" href="../../style/book-style.css"/>
</head>
<body epub:type="bodymatter">
<!-- Navigation -->
<h1>Matz Essays Volume 1</h1>
<p class="navigation-top"><a href="../../index.xhtml">HOME</a>　&gt;　<a href="../index.xhtml">Volume 1</a>　&gt;　第1章</p>
<!-- Body -->
<section id="chap01" class="level1">
<a id="page_003"/>
<span class="chap-title">Matz Essay</span><span class="chap-num">1</span>
<hr class="chap-hr" />
<h2>
<span class="fontsmall">言語にとって美とはなにか?</span><br />
Rubyにみるスクリプト言語の<br />実装技法
</h2>
<hr class="chap-hr" />
<p class="right">[<span class="it">TransTECH</span>, 1999年8月号]</p>
<div class="newlead">
<p class="ih">『ドクター・ドブズ・ジャーナル日本版』から改装された雑誌『TransTECH』1999年8月号の大特集「言語にとって美とはなにか?」に掲載された原稿です。掲載誌は今でも記念として私の本棚を飾っていますが、「美とはなにか」という大げさなタイトルの割に、この特集の中で「言語の美」を直接扱った記事は、私のものを含めて存在しなかったように思います。『TransTECH』はなかなか骨太な雑誌で、記事の内容も好みのものが多かったのですが、残念ながら翌年2000年4月号で休刊しています。本家『Dr. Dobb’s Journal』も休刊してしまうし、紙の雑誌は受難ですね。</p>
<p class="in">記事の内容としては1999年当時のRubyの実装や言語実装に関するテクニックを解説しています。YARV仮想マシンが導入される1.8以前を対象とした解説ではありますが（当時のバージョンは1.2）、20年以上経った現在でも有効な内容が多いと思います。言語処理系を作りたい人の参考になるかもしれません。でも、今だったらRuby 1.8のようなtree walking interpreterではなくてVMを実装することをお勧めします。当時はまだ20世紀で、その頃はtree walkingは珍しくなかったんですけどねえ。Ruby自身は本文中「やらないと思っている」と書いた「VM」「世代別GC」や「JITコンパイラ」なども実装していて、隔世の感があります。</p>
<p class="in">それから、他の記事もそうですが、記事中のリンクが、Ruby自身のものを含めて切れているのがインターネット時代にはかなさを感じます。むしろデジタルデータのほうが消滅しやすいですね。ただ、「<span class="link">GC FAQ</span>」だけは2024年現在も健在ですばらしいと思います。</p>
</div>
<section id="chap0101" class="level2">
<h3>はじめに</h3>
<hr class="hr-gray" />
<p class="in">最近のコンピュータの普及に従ってプログラミング人口はますます増加しています。ほとんどの場合プログラミングには何らかのプログラミング言語を使うことになります。それらの言語の中にはCやJava, Pascalのようなメジャーなものから、各種アプリケーションに組み込みのいわゆるマクロ言語や簡易言語と呼ばれるものまでさまざまなものがあります。</p>
<a id="page_004"/>
<p class="in">このようにプログラマーとは切っても切れない関係のプログラミング言語も、実際にその処理系を実装したことのある人はそれほど多くはありません。自分のプログラミング言語を設計したことがある人はもっと少ないでしょう。</p>
<p class="in">しかし、コンピュータがこの世に登場してからこのかた数多くのプログラミング言語が設計されました。その中には世の人々にほとんど知られることなく衰退してしまったものも数知れずあります。The Language List &lt;<span class="link">http://cuiwww.unige.ch/langlist</span>&gt; はそのようなプログラミング言語を集めたカタログですが、ここに収録されているある程度知られた言語に限っても2400くらいあります。知られていない言語の数がいったいどのくらいになるのかとても想像がつきません。</p>
<p class="in">なぜこのように数多くのプログラミング言語が存在するのでしょうか?　確かな理由は推測するしかありませんが、プログラミング言語の設計と実装にはプログラマーを引きつける「何か」があるのは確かです。私自身がその魅力に取りつかれた人間の一人ですから、間違いありません。</p>
<p class="in">プログラミング言語の設計と実装はある意味でソフトウェア工学の総決算ともいえます。少し考えただけでも<a href="#table0101">表1.1</a>のような分野を包含しています。</p>
<div class="table" id="table0101">
<p class="tbl-caption">表1.1●ソフトウェア工学の総決算</p>
<table class="tbl01">
<tr>
<td>人間工学</td>
<td>モデルとアルゴリズムの記法</td>
</tr>
<tr>
<td>言語理論</td>
<td>コンパイラ設計、最適化</td>
</tr>
<tr>
<td>アルゴリズム</td>
<td>文字列処理、記号処理、数値処理</td>
</tr>
<tr>
<td>データ構造</td>
<td>リスト、配列、ハッシュ</td>
</tr>
<tr>
<td>OSインターフェイス</td>
<td>システムコール、ネットワーク、動的リンク</td>
</tr>
<tr>
<td>高速化</td>
<td>アルゴリズムの選択、チューンアップ</td>
</tr>
</table>
</div>
<p class="in">私の経験からいうとおもちゃのような言語を実装するだけでも相当いろいろ考えることがあり、これほど楽しいプロジェクトはなかなかないと思います。</p>
<p class="in">一方、機能・性能の面から「使いものになる」インタプリタを作るにはただ楽しいだけでは済まないいろいろな工夫が必要になります。この記事ではプログラミング言語の設計者・実装者の立場から、オブジェクト指向スクリプト言語であるRubyの実装を例にしながら、プログラミング言語の実装技法を解説します。</p>
</section>
<section id="chap0102" class="level2">
<h3>Rubyとは</h3>
<hr class="hr-gray" />
<p class="in">本題に入る前に、Rubyについてご存じない方もいらっしゃるでしょうから、このオブジェクト指向スクリプト言語についてひととおり紹介しておきましょう。</p>
<p class="in">Rubyは、私「まつもと ゆきひろ」によって設計・開発されたスクリプト言語です。Rubyは1993年から開発が始まりました。ライバルであるPerlやPythonよりもやや若い言語です。実際、Perl（真珠は6月の誕生石）を意識して、Ruby（ルビーは7月の誕生石）と名付けられています。</p>
<p class="in">その主要な特徴は、</p>
<ul>
<li><p>フリー（オープンソース）ソフトウェア</p></li>
<li><a id="page_005"/><p>インタプリタによるお手軽さ</p></li>
<li><p>シンプルな文法</p></li>
<li><p>強力な組み込み機能</p></li>
<li><p>オブジェクト指向による統一感</p></li>
<li><p>型宣言が不要</p></li>
<li><p>イテレータとクロージャ</p></li>
<li><p>例外処理機能</p></li>
<li><p>メモリ管理が不要</p></li>
<li><p>Cによる拡張が容易</p></li>
<li><p>ダイナミックローディング</p></li>
<li><p>スレッド機能</p></li>
<li><p>どこでも動くポータビリティ</p></li>
<li><p>小さなプログラムから大きなプログラムまでカバーするスケーラビリティ</p></li>
</ul>
<p class="ni">などがあります。RubyはPerlが使えるような分野にはほとんど適用できます。具体的にはテキスト処理、CGIなどのWWWプログラミング、システム管理、ネットワークプログラミング、GUIプログラミングなどです。しかも、Perlよりもプログラムが暗号のようになりにくい傾向があるので、まだまだマイナーであることを除けば、Perlの代替として十分機能します。</p>
<p class="in">しかし、作者の目から見るとこの言語は単なるスクリプト言語ではありません。というのも、Rubyはオブジェクト指向とプログラミング言語に魅せられたプログラマーの理想の追求の結果だからです。やや大げさですが。</p>
<p class="in">私はいわゆる簡易言語が大嫌いです。簡易言語の「簡易」とは「簡単に使える言語」ではなく、「簡単に作れる言語」を意味しています。要するに言語仕様における手抜きです。言語仕様とはプログラミング言語の使いやすさを決める最も重要な要素です。Rubyはある意味理想の追求ですから、このような部分においては妥協できません。もっとも、本質に関係ない部分では結構手抜きがあるのですが。</p>
<p class="in">さて、本稿の主題は言語処理系の実装についてですから、これ以上Ruby言語そのものについては解説しません。参考までにRubyによる簡単なプログラムのいくつかを<a href="#list0101">リスト1.1</a>に示しておきます。</p>
<div class="plistc" id="list0101">
<p class="lst-caption">リスト1.1●Rubyのサンプルプログラム</p>
<pre><span class="cmt"># 由緒正しい Hello World.</span>
print <span class="str">&quot;Hello World\n&quot;</span>

<span class="cmt"># 入力ファイルの&quot;From &quot;を含む行を印刷する</span>
<span class="kwd">while</span> line = gets()
  <span class="kwd">if</span> line =~ <span class="mcm">/^From /</span>
    print line
  <span class="kwd">end</span>
<span class="kwd">end</span>

<span class="cmt"># 引数で指定したファイル名を小文字にそろえる</span>
ARGV.each {|path| File.rename(path, path.downcase)}

<span class="cmt"># TkによるGUI</span>
require <span class="str">&#39;tk&#39;</span>
TkButton.new(<span class="str">nil</span>, <span class="str">&#39;text&#39;</span>=<span class="str">&gt;&#39;hello&#39;</span>, <span class="str">&#39;command&#39;</span>=&gt;<span class="str">&#39;exit&#39;</span>).pack
Tk.mainloop</pre>
<hr class="hr-gray" />
</div>
<a id="page_006"/>
<p class="in">より詳しくはRubyホームページ &lt;<span class="link">http://www.netlab.co.jp/ruby/jp</span>&gt; を参照してください。</p>
</section>
<section id="chap0103" class="level2">
<h3>性能向上の原則</h3>
<hr class="hr-gray" />
<p class="in">さて、実装の話に移る前にプログラムの性能を向上させる場合一般に適用できる原則について紹介しておきます。</p>
<p class="in">プログラムの性能にはいくつかの種類があります。空間効率（少ないメモリで動作する）、実行効率（処理が速く完了する）、操作性（使いやすい）、開発効率（プログラムが速く完成する）などがあります。が、プログラムの性能というと普通は実行効率（まれに空間効率）を意味するでしょう。</p>
<p class="in">プログラムの実行効率を向上させるにはやみくもにプログラムをいじってもあまり効果がありません。むしろバグを増やすのに貢献するのみです。狙いを定めて対応する必要があるのです。</p>
<p class="in">プログラムの性能の問題はほとんどの場合はプログラム全体から見れば小さな部分に存在しています。よく80 : 20則あるいは90 : 10則と呼ばれるのですが、プログラムの実行時間の8割はプログラム全体の2割のコードで消費されている（あるいは9割を1割で消費している）ことが多いという経験則が知られています。性能の改善にはこのようなボトルネックの部分を見つけて対処することが肝心です。</p>
<p class="in">プログラムのある部分を苦労して改善して半分の時間で処理が終了するように効率化したとしても、その部分が全体の実行時間の2%しか消費していなかったら、プログラム全体としては1%、ほとんど誤差のレベルでしか実行効率が改善しません。これでは苦労するだけ無駄です。</p>
<p class="in">ですから、実行効率の改善を図る前には必ずどこがボトルネックであるのか分析する必要があります。このような分析を「プロファイルを取る」といいます。プロファイルを取るツールをプロファイラといいます。</p>
<p class="in">UNIXでは伝統的に<code>prof</code>や<code>gprof</code>というプロファイラが使えます。このツールはどの関数が実行中に何回呼ばれて、それぞれの消費時間はどのくらいであったかを測定します。商用のツールになりますが、日本ラショナルのQuantifyはより細かく行単位でボトルネックの検査ができる優れたツールです。</p>
<p class="in">ボトルネックを見つけると今度は実際の対策にかかるわけですが、その場合には以下の優先順位で対応すべきです。</p>
<ol>
<li><p><span class="k">アルゴリズムの改善</span><br />
もっと効率のよいアルゴリズムを選択する。最も有効な対策。これに手を付けないで小手先の対応は意味がない。</p></li>
<li><p><span class="k">データ構造の改善</span><br />
たとえばデータをヒープに持つか、スタックに持つかとか、無駄なデータを省くとか一本化するとか。</p></li>
<li><a id="page_007"/><p><span class="k">小手先の改善</span><br />
関数のインライン展開とか、ループの展開や置き換えなど。</p></li>
</ol>
<p class="in">決して逆の順序で行ってはいけません。というのも、小手先の改善では数割、うまくいっても数倍しか改善できない場合がほとんどですが、アルゴリズムを変える場合には、ときには100倍以上の劇的な改善が可能な場合もあるからです。</p>
<div class="column">
<p class="column-title">プログラミング言語における型</p>
<p class="in">プログラミング言語の性質を決める重要な要素に型があります。プログラミング言語における型には大きく分けると以下の2種類があります。</p>
<ul>
<li><p>静的な型</p></li>
<li><p>動的な型</p></li>
</ul>
<p class="in">静的な型とはプログラムの字面上に登場する型です。たとえばCプログラムの変数宣言、</p>
<div class="plist">
<pre><span class="kwd">int</span> i</pre>
</div>
<p class="ni">は<code>i</code>という変数が<code>int</code>（整数）型であることを示しています。<code>int</code>型の変数は整数データの格納場所になります。静的な型は変数だけでなく式にも適用されます。</p>
<p class="in">動的な型とはプログラムの字面には登場せず、実行時に決まる「値の型」です。Cにはこのような概念は（言語仕様としては）登場しないのですが、たとえばJavaには、</p>
<div class="plist">
<pre>Object obj = <span class="kwd">new</span> String;</pre>
</div>
<p class="ni">のように変数の型とは違う「オブジェクトの型」が存在します。上の例では変数の型は<code>Object</code>であり、その変数の値の型は<code>String</code>です。変数<code>obj</code>の型（静的な型）を見ただけでは実際にその変数の値の型はわかりません。</p>
<p class="in">プログラミング言語をこの型の観点から分類すると以下のようになります。</p>
<ul class="none">
<li><pre class="tabbing"><span class="k">型のない言語</span>　　　　　AWK, BCPL, アセンブラ</pre></li>
<li><pre class="tabbing"><span class="k">静的な型のみの言語</span>　　C, Pascal</pre></li>
<li><pre class="tabbing"><span class="k">両方ある言語</span>　　　　　Java, Eiffel, Perl</pre></li>
<li><pre class="tabbing"><span class="k">動的な型のみの言語</span>　　Lisp, Smalltalk, Ruby</pre></li>
</ul>
<p class="in">静的な型のある言語は型のチェックをコンパイル時に行うことができるので、エラー検出が早いタイミングでできることと、型情報を使ってプログラム解析をより詳細に行うことができる（それによってより最適化できる）ことが利点です。</p>
<p class="in">一方、動的な型のみの言語はエラー検出が遅れるというデメリットはありますが、変数の型を厳密に考えなくても気軽にプログラミングできる、オブジェクトに対する扱いに柔軟性が高いという利点があります。</p>
</div>
</section>
<section id="chap0104" class="level2">
<a id="page_008"/>
<h3>Rubyの実装</h3>
<hr class="hr-gray" />
<p class="in">さて、ようやくRubyの実装を見てみることにしましょう。Rubyインタプリタの構成は<a href="#fig0101">図1.1</a>のようになっています。</p>
<div class="fig" id="fig0101">
  <!-- <div class="image40"> -->
  <div class="image400">
      <img src="../image/ch01/1-1.jpg" alt="fig0101" />
  </div>
  <p class="fig-caption">図1.1●Rubyインタプリタの構成</p>
</div>
<section id="chap010401" class="level3">
<h4>コンパイラ</h4>
<p class="in">Rubyはインタプリタ型の言語ですが、実際には最初にプログラムを全部読み込んで、コンパイラ部が構文解析を行います。構文解析の結果である構文木を後段の構文木インタプリタが逐次解釈するわけです。このようにまずコンパイラでプログラムを内部構造へ変換する方式をコンパイラ・インタプリタ方式と呼び、最近のスクリプト言語では主流の構成になっていて、PerlやPythonなどでも採用されています。</p>
<p class="in">古いタイプのインタプリタ言語ではバージョン7.6以前のTclのようにプログラムを文字列として扱ったり、あるいはある種のBASICのように予約語を1バイトの記号に置き換えた中間言語を使ったりしていました。このような方式のインタプリタに比べるとコンパイラ・インタプリタ方式は、</p>
<ul>
<li><p>構文解釈のコストを削減できる</p></li>
<li><p>文法エラーを実行前に発見できる</p></li>
</ul>
<p class="ni">というメリットがあります。</p>
<p class="in">Rubyのコンパイラ部（パーサーと呼ぶこともあります）は、UNIXでの一般的なコンパイラ生成ツールであるyaccを使っています。</p>
<p class="in">yaccはBNFと呼ばれる言語の文法の記述と結果を出力するプログラム（の断片）から、パーサーを自動生成してくれる優れもののツールです。yaccはRubyを始めとする多くの言語処理系で採用されています。</p>
<p class="in">パーサーの出力は言語によってまちまちです。たとえばRubyやPerlでは構文木と呼ばれる構造体のリンクですし、PythonやSmalltalkやバージョン8.0以降のTclではバイトコードと呼ばれる一種の仮想機械のマシン語を出力します。</p>
<p class="in">構造体のリンクである構文木は柔軟で実装が容易であるというメリットがあり、一方バイトコードはコンパクトでメモリ効率がよいというメリットがあります。</p>
<p class="in">コンパイラ部の効率を改善する方法としては出力をそのまま書き出して2回目以降のコンパイルを回避するというものがあります。この方法はPythonやEmacsなどで用いられています。Pythonはスクリプトを読み込んだときにディレクトリが書き込み可であればコンパイル結果のバイトコードを書き込んでしまうという大胆な方法を採用しています。</p>
<a id="page_009"/>
<p class="in">Rubyでもかつてこのコンパイル結果を書き出す方法を採用するかどうかの検討を行ったことがあります。しかし、プロファイルを取ってみるとコンパイル部の実行時間は全体にほとんど影響を与えていないことが明らかになりました。コンパイルはプログラムの実行直前に一度しか行われず、かつ内部構造へのコンパイルは十分に高速なので、ボトルネックになりにくいのでした。Rubyはもともと書き出しを行いにくい構文木方式を採用していたこともあって、この手法は割に合わないということで採用を見送りました。おそらく今後も採用されることはないでしょう。</p>
<p class="in">結論としてはコンパイラ部は現状でもかなり高速なうえ、時間をあまり消費していないので、速度の点ではあまり改善の余地がないといえるでしょう。</p>
</section>
<section id="chap010402" class="level3">
<h4>最適化</h4>
<p class="in">コンパイラの実装の中で重要な分野として「最適化」と呼ばれるものがあります。最適化とはプログラムの実行効率を向上させる処理です。たとえば無駄な処理を省いたり、先に計算できるものをあらかじめ計算しておくなどの「小手先」の改善をコンパイラに行わせるものです。歴史的な事情から「最適化」と呼ばれていますが、実際には「最適」にすることなどできるはずもなく、本来ならいわば「ちょっとマシ化」とでも呼ぶべきものです。</p>
<p class="in">コンパイラ型の言語ではこれらの最適化は非常に有効で、たとえばCコンパイラの最適化オプションを付けるかどうかで処理時間が相当変化することはざらです。</p>
<p class="in">具体的な最適化にはたとえば以下のようなものがあります。</p>
<ul>
<li><p>式展開（<code>x**2</code> → <code>x*x</code>など）</p></li>
<li><p>定数畳み込み（<code>2+1</code> → <code>3</code>, <code>"a"+"b"</code> → <code>"ab"</code>など）</p></li>
<li><p>共通部分式の除去</p></li>
<li><p>不要コードの除去</p></li>
<li><p>コードの並べ替え</p></li>
<li><p>ループ展開</p></li>
<li><p>インライン展開</p></li>
</ul>
<p class="in">しかし、残念なことにRubyのような動的な性質の強い言語ではこの最適化はほとんど適用できません。</p>
<p class="in">まず、第一にRubyには変数や式に型がないので、型情報を用いた式展開などができません。<code>x+y</code>という式を見てもそれぞれの変数に数値が入っているのか、文字列が入っているのかによって実際の処理が異なるので、あらかじめ計算することができないのです。</p>
<p class="in">また、演算子も一種のメソッドでプログラム中で再定義することが可能なので（その気になれば整数の加算なども置き換えられる）、その点からも最適化は困難です。副作用がないことがはっきりわかっていれば、共通部分式や不要コードの除去やコードの並べ替え、ループ展開などが可能ですが、そのことを保証する方法も提供されていません。</p>
<p class="in">プログラムの解析によって実際に起動される処理を決めることができないのでインライン展開も行えません。</p>
<a id="page_010"/>
<p class="in">Rubyの動的で柔軟な性質は、プログラムの書きやすさや使いやすさにつながりますが、プログラムの実行効率、特に最適化という点からはやや厳しいものがあります。</p>
</section>
<section id="chap010403" class="level3">
<h4>C言語へのコンパイル</h4>
<p class="in">最近のマシンの高速化によって実行速度に不満を感じる機会は以前より少なくなりましたが、やはりインタプリタ型の言語はコンパイラ型の言語よりも10倍から100倍程度実行速度が遅い場合がほとんどです。</p>
<p class="ih">「インタプリタは遅い」というとたいていの人がすぐに思い付くのは、「コンパイルして実行形式にすれば高速化できる」ということでしょう。</p>
<p class="in">しかし、世の中はそうは甘くないものです。Rubyにはまだありませんが、同じ分野のスクリプト言語であるPerlやPythonにはプログラムをC言語に変換して、それをコンパイルすることにより実行形式を得ることができるツールがすでに開発されています。しかし、やや意外なことではありますが、実行速度はほとんどの場合、10倍どころか数割改善されれば上出来という程度のようです。</p>
<p class="in">というのも、動的な性質を持つスクリプト言語では、コンパイル時の最適化が難しいのと同様の理由でC言語に変換することによるメリットを受けにくいことが原因です。</p>
<p class="in">また、実行時間の多くはコンパイルすることで短縮されるインタプリタによる制御部分ではなく、もともとC言語で記述されコンパイラ型言語の速度で実行されるライブラリルーチンの中で消費されることも関係しているようです。</p>
<p class="in">結局、実行形式にコンパイルすることによってインタプリタの制御の部分を直接コンパイルされたスピードで実行できても、それは全体の実行時間から見ると数割にすぎません。その数割のためにかなり複雑になるC言語への変換ツールを作るかと問われるとかなり悩むのが正直なところです。なにしろコンピュータは放っておいてもどんどん高速化しているのですから。</p>
</section>
<section id="chap010404" class="level3">
<h4>インタプリタ</h4>
<p class="in">コンパイラによる改善に限界があるとすれば、実際の処理を実行するインタプリタ部はどうでしょうか。実際にプロファイルを取ると、インタプリタを構成する関数はたいてい時間を消費する関数のトップテンに入っているようです。</p>
<p class="in">Rubyのインタプリタ部はコンパイラ部が生成した構造体（ノード）のリンクである構文木を解釈します。インタプリタ部の本体は<code>rb_eval()</code>という関数で、その本体はノードの種別ごとに各種の処理を行う巨大な<code>switch</code>文になっています。</p>
<p class="in">現状の構文木インタプリタは以下のような高速化のための工夫を行っています。</p>
<ul>
<li><p>シンボル</p></li>
<li><p><code>alloca</code>の利用</p></li>
<li><p>メソッドキャッシュ</p></li>
</ul>
<p class="in">これらの工夫を具体的に見てみましょう。</p>
<div class="description">
<p class="ditem">シンボル</p>
<p class="dni">プログラムに登場する識別子（変数やメソッドなどの名前）は、コンパイラによってそれと1対1対応するシンボルと呼ばれる整数値に変換されます。インタプリタ内部では文字列としての名前は扱いません。これにより識別子の比較や検索が大幅に高速化されています。また、文字列を管理する必要がないので、メモリの節約と同時にメモリ管理の単純化にも貢献しています。</p>
<a id="page_011"/>
<p class="ditem"><code>alloca</code>の利用</p>
<p class="dni">ヒープ上に領域を割り当てる<code>malloc()</code>に対して、スタック上に領域を割り当てるのが<code>alloca()</code>です。<code>alloca()</code>で割り当てられた領域はその関数を終了するまで有効で、関数が終了すると（スタックですから）自動的に解放されます。サイズを自由に指定できるローカル配列のようなものだと考えることができるでしょう。<code>alloca()</code>のもう1つの特徴は、例外もありますが、ほとんどのマシンでは<code>malloc()</code>よりも高速に割り当てを行うことです。Rubyインタプリタでは<code>alloca()</code>を利用して高速化を図っています。ただし、<code>alloca()</code>は多用するとスタックを過剰に消費してしまう欠点がありますので、1つの関数の中で繰り返し領域を割り当てたりする用途には使わないようにしなければなりません。</p>
<p class="ditem">メソッドキャッシュ</p>
<p class="dni">オブジェクト指向言語ではメソッドの呼び出し対象になったオブジェクトによって実際に起動されるメソッドが決まります。ですから、どのオブジェクトに対してどの名前のメソッドが呼ばれたかという情報によって、メソッド呼び出しごとにテーブルを検索して実際の処理を選択する必要があります。</p>
<p class="din">Rubyのような純粋オブジェクト指向言語では、ほとんどあらゆる処理がメソッドによって処理されますから、このメソッド検索のコストは非常に大きくなります。</p>
<p class="din">そこでRubyではメソッドキャッシュという手法を使ってこの検索コストを低減させています。具体的には、メソッド検索を行った場合、このオブジェクトに対してこの名前のメソッドを呼び出したら、実際にはこの処理を行ったという情報を、クラスとメソッド名をキーにしてメソッドキャッシュと呼ばれるテーブルに保存します。メソッド検索が発生するとまずメソッドキャッシュを調べ、そこで見つからなかったときに初めてオブジェクト内部のテーブルを検索します。</p>
<p class="din">このメソッドキャッシュは単純ですが、非常にヒット率が高く、ある調査では95%のメソッド呼び出しでキャッシュヒットしています。これによりかなりの効率改善が行われます。</p>
</div>
<p class="in">インタプリタの効率改善にはこの他にも以下のようなものがあります。</p>
<div class="description">
<p class="ditem">インラインメソッドキャッシュ</p>
<p class="dni">これはSmalltalkの一部の処理系で採用されている方法で、上記のメソッドキャッシュのようなグローバルなテーブルではなく、呼び出しコードの中に前回の呼び出し情報を保存しておくというものです。</p>
<p class="din">この方法は同じ場所でのメソッド呼び出しはほとんどの場合同じオブジェクトに対して行われるという経験即に基づくものです。</p>
<p class="din">実は、以前実際にこのインラインメソッドキャッシュをRubyに実装したことがあるのですが、結果はほとんど実行結果に影響を与えませんでした。すでに採用していたメソッドキャッシュが十分な効果をあげていたからのようです（あるいは私の実装がまずかったのかもしれませんが）。</p>
<a id="page_012"/>
<p class="ditem">threaded code</p>
<p class="dni">threaded code（縫い糸コードとも呼ばれる）は構文木のノードにノードの種別の代わりに実際にそのノードの処理を行う関数へのポインタを埋め込むものです。これにより<code>switch</code>文の分岐のコストを削減することができるはずです。</p>
<p class="din">これも実装してみましたが、目に見える効果はなく、むしろやや遅くなる傾向がありました。はっきりとした原因は不明ですが、おそらくは最近の最適化されたCコンパイラの生成する<code>switch</code>文の分岐は十分に高速で、threaded codeにより関数呼び出しが増えてしまうことによるデメリットを補えなかったのではないかと推測します。</p>
<p class="ditem">JIT（Just In Time compile）</p>
<p class="dni">JITは実行する時点で動的にマシン語に変換し、それを実行するという手法で、Javaでよく用いられています。しかし、この方法は（当然ですが）各CPUに固有の方法になってしまい、同じインタプリタのソースコードをいろいろなマシンで使う移植性を維持するのが難しくなります。</p>
<p class="din">やればある程度（数割くらい?）の効果はありそうですが、将来のRubyインタプリタでこの方法が採用される可能性は低いでしょう。</p>
<p class="ditem">型仮定</p>
<p class="dni">コンパイル部で最適化できない理由の1つは動的な言語ではプログラムに型情報がないからと言いました。だったら型情報に依存しないルーチンと、ある型を仮定して、その条件が成立するときだけ高速で実行するルーチンの両方を用意すればよいというのがこのアプローチです。この手法は非常に興味深いので、後述のHotSpotと合わせて将来いつか挑戦してみたいと考えています。</p>
<p class="ditem">HotSpot</p>
<p class="dni">HotSpotはSunが提出しているJavaの高速化手法の名称です。詳細は不明ですが、基本的な原理は実行時に統計情報（一種のプロファイル）を集め、それを元にボトルネックの部分で集中的に動的最適化を行うもののようです。</p>
<p class="din">統計用のコストがどのくらいの割合になるのか不明ですが、実行時に情報収集して、それを元に高速化を行うというのは面白いアイデアだと思います。</p>
</div>
<p class="in">このようにインタプリタの改善にはまだまだできることがありそうです。</p>
</section>
<section id="chap010405" class="level3">
<h4>メモリ管理</h4>
<p class="in">オブジェクト指向言語、特に純粋オブジェクト指向言語では、配列、文字列、数値に至るまでのあらゆるデータがオブジェクトなので、プログラムの実行中に大量のオブジェクトを割り当てる傾向があります。</p>
<p class="in">これらのオブジェクトをすべて管理することをプログラマーに要求するとしたら、大変なことになります。プログラマーはどのオブジェクトがいつまで生きているべきか1つ1つ管理して、用事が終われば1つ残らず解放しなければなりません。もし解放するのを忘れたり、あるいはまだ使っているのに解放してしまったりしたら、深刻でなおかつ非常に発見しにくいバグの原因になります。</p>
<p class="in">しかし、実際にC++というオブジェクト指向言語ではこのようなことを要求しています。まったく信じられないような話です。</p>
<p class="in">一方、C++よりは「ちゃんと」設計された言語であるJavaではこのような問題に対しての対抗策が用意されています。それはガベージコレククション（GC）と呼ばれる機能です。ガベージコレクションはもう使われなくなったオブジェクトを自動的に検出し、解放処理を行ってくれます。もちろん、Rubyにもこの機能があります。</p>
<a id="page_013"/>
<p class="in">C++の賛同者の中にはプログラマーが明示的にメモリ管理を行ったほうが（たとえ少々問題が発生しやすくても）、結果的によい性能が出るという主張があるようです。しかし、最近の研究ではコンピュータの性能向上もあいまって、ほとんどの場合には自動的にメモリ管理を行うGCを使ったほうが性能がよいという結果も出ています。</p>
<p class="in">ここではまずGCの理論について簡単に説明してから、RubyでのGCの実装について見てみましょう。</p>
<p class="in">GCはプログラミング言語の中でも重要なテーマです。最近のほとんどのプログラミング言語は何らかの形でオブジェクトを操作する機能を持ち、C++のような冷酷な言語を除けばオブジェクト操作機能を支援するために何らかのGC機能を持つものが珍しくありません。</p>
<p class="in">ガベージコレクションの手法としては以下のようなものがあります。</p>
<div class="description">
<p class="ditem">リファレンスカウント</p>
<p class="dni">リファレンスカウント（reference count）はオブジェクトを回収する手法の中では最も「手軽」でPerl, Python, Tcl（8.0以降）を始めとする多くの言語で採用されています。リファレンスカウント方式では、あるオブジェクトが参照されている数をいつも把握しています（<a href="#fig0102">図1.2(a)</a>）。この参照されている数（これをリファレンスカウントと呼びます）がゼロになったオブジェクトはどこからも参照されていないので、回収することができるというわけです（<a href="#fig0102">図1.2(b)</a>）。</p>
<div class="fig" id="fig0102">
  <!-- <div class="image70"> -->
  <div class="image500">
      <img src="../image/ch01/1-2.jpg" alt="fig0102" />
  </div>
  <p class="fig-caption">図1.2●リファレンスカウント</p>
</div>
<a id="page_014"/>
<p class="din">この方式のメリットは実装が簡単なことと、オブジェクトが使われなくなったらすぐに回収されることが期待できる点です。この特長は他のGC手法ではまず実現できません。</p>
<div class="plistd">
<pre>f = open(<span class="str">&quot;/path/to/file&quot;</span>, <span class="stg">&quot;r&quot;</span>)
  ... fを使った処理 ...
f = <span class="kwd">nil</span>        <span class="cmt"># ここでfの解放処理が期待できる</span></pre>
</div>
<p class="din">別の特長としてはオブジェクトの回収処理がプログラムの本来の処理の中で少しずつ行われるので、GC処理による中断がほとんどないということがあります。</p>
<p class="din">この方式のデメリットはサイクルのあるデータを回収できないことです（<a href="#fig0102">図1.2(c)</a>）。サイクルのあるデータは全体として参照されなくなっても、個々のオブジェクトの参照数がゼロになりませんから、回収されずゴミになります。</p>
<p class="din">オブジェクト指向プログラミングではたくさんのオブジェクトがお互いに参照しあうので、サイクルのあるデータ構造はしばしば発生すると考えられます。この場合ゴミにならないためには用事が済んだ時点で明示的にサイクルを切る必要があります。これはプログラマーにとってはかなり面倒な要求です。</p>
<p class="din">また、実装者の立場からいうと参照数の増減を忘れてしまうバグに悩まされやすいというのもデメリットです。</p>
<p class="ditem">マーク・アンド・スイープ</p>
<p class="dni">マーク・アンド・スイープ（mark and sweep）は、最も古く考案され、最も広く使われているGC手法です。</p>
<p class="din">マーク・アンド・スイープでは、ルート（root = 根）と呼ばれるオブジェクトから芋づる式にたぐれるオブジェクトにすべてマークを付け、マークの付いていないオブジェクトはもう使われていないものとみなして回収するという方法です。</p>
<p class="din">マーク・アンド・スイープは長らく「古い」という理由であとで説明するストップ・アンド・コピーやその変形であるジェネレーション・スキャベンジングに押されていましたが、単純さとスレッドなどの並行動作との相性のよさから見直されてきています。</p>
<p class="din">マーク・アンド・スイープは全オブジェクトをスキャンするので、GC中に処理が停止するという欠点があります。これがかつてリファレンスカウントが人気であった理由の1つだったのですが、しかし、最近のコンピュータの性能向上とアルゴリズムの改善のおかげでそのことが問題になることはほとんどなくなりました。</p>
<p class="ditem">ストップ・アンド・コピー</p>
<p class="dni">ストップ・アンド・コピー（stop and copy）はオブジェクトのためのメモリを切り出してくるための領域を2面持ち、一方がいっぱいになると、ルートからたぐることのできる「生きている」オブジェクトを別の面にコピーする方法です。別の面へのコピーが終わればすべての「生きている」オブジェクトがそちらに移動していますから、それ以上の回収作業は不要です。</p>
<p class="din">ストップ・アンド・コピーは、GCの処理時間がオブジェクトの総数ではなく、「生きているオブジェクト」の数で決定されるというメリットがあります。また、参照される可能性のあるオブジェクトがコピーによって集められるので（コンパクションと呼びます）、一度にアクセスするメモリ空間を小さくできます。このプログラムが同時にアクセスするメモリ空間をワーキングセットと呼ぶこともあります。ワーキングセットが小さいと、OSのページング機能にかける負荷が減り、性能が向上する可能性があります。</p>
<a id="page_015"/>
<p class="din">しかし、領域が2面必要になるので割り当てた領域の半分しか活用できず無駄が多いのと、個別のオブジェクトの回収処理を行わないので、メモリ以外の資源の後始末（ファイルのクローズとか）が難しいという欠点もあります。</p>
<p class="ditem">ジェネレーション・スキャベンジング</p>
<p class="dni">ジェネレーション・スキャベンジング（generation scavenging）は、ストップ・アンド・コピーの変形で「無駄な領域」という欠点を少し改善したうえで、オブジェクトの回収効率を向上させています。</p>
<p class="din">オブジェクトの振る舞いの一般的な傾向として、寿命の短いオブジェクトは徹底的に短く、寿命の長いオブジェクトはかなり長いということがいえます。この傾向を利用して、オブジェクトを世代別に分類し、若い世代は頻繁に、古い世代はときどきスキャンするというのがジェネレーション・スキャベンジングの基本原理です。</p>
<p class="din">ただし、ジェネレーション・スキャベンジングは実装が非常に難しいという欠点があります。</p>
</div>
<p class="in">それぞれ利点と欠点のあるGC手法ですが、Rubyはこの中でマーク・アンド・スイープ方式を採用しています。理由はリファレンスカウント方式のデメリットが妥協できなかったことと、ストップ・アンド・コピー方式、およびその後継のジェネレーション・スキャベンジング方式では必然的にオブジェクトの移動が発生するので、インタプリタの実装が飛躍的に難しくなるからです。</p>
<p class="in">RubyのGCの特徴はルートとして、C言語の大域変数領域とCPUのスタックとレジスタも使う点です。もちろんCPUはどの値がポインタで、どの値が整数かという情報は記録されていませんが、たまたまオブジェクトのアドレスと同じ整数値が存在した場合には、ポインタであるかもしれないので安全側に倒して参照されているとみなすことにしています。</p>
<p class="in">このようなGCを、安全側に倒すことから「保守的」という意味のコンサバティブ（conservative）GCと呼びます。コンサバティブGCの利点は、C言語のローカル変数に格納されたRubyのオブジェクトへの参照をGCに明示的に教えてやらなくても自動的に検出できることです。これはインタプリタの開発者（つまり私）の開発効率を飛躍的に向上させます。また、明示的な指定を忘れてしまうことによるバグがなくなることにより、間接的にユーザーも恩恵を受けることになります。</p>
<p class="in">コンサバティブGCはポインタと整数値の区別が付けられないので、ポインタの付け替えを伴うストップ・アンド・コピーなどには適用できません。Rubyがストップ・アンド・コピーを使っていないのはそのことも理由の1つです。</p>
<p class="in">RubyのコンサバティブGCでは大域変数はユーザーに明示的に指定してもらうことにしています。スタックの範囲はローカル変数のアドレスから計算し、その領域内から参照されている（ように見える）すべてのオブジェクトにマークします。レジスタの内容はCのライブラリ関数である<code>setjmp()</code>がレジスタの状態を保存する<code>jmp_buf</code>構造体から参照します。</p>
<p class="in">オブジェクトでないメモリ領域、たとえば文字列の内容などは単純に<code>malloc()</code>と<code>free()</code>を使って管理しています。というのも任意長のメモリ領域については、下手に自前で管理するよりもOSが提供している関数を使ったほうが効率が高いことが多いからです。</p>
<a id="page_016"/>
<p class="in">Emacsでは文字列領域をプールと呼ばれる領域から割り当て、GCのときに使われていない領域を詰めてコンパクションを行っています。これはワーキングセットを小さくすることを目的としていると思われますが、最近はコンピュータに搭載されているメモリ容量が増えたこともあって、それほど劇的な変化はないようです。</p>
<p class="in">参照されなくなってゴミになるのはなにもメモリだけとは限りません。たとえばオープンしっぱなしで誰からも参照されなくなったファイルなどもゴミになります。このようなメモリ以外の資源についてもGCのタイミングで解放してやる必要があります。Rubyはこれもサポートしていますから、たとえば、</p>
<div class="plist">
<pre>txt = open(<span class="str">&quot;/path/to/file&quot;</span>, <span class="str">&quot;r&quot;</span>).readline</pre>
</div>
<p class="ni">のように明示的なクローズを省いてしまってもちゃんと動作します。ま、きちんとクローズしたほうがお行儀が良いとは思いますけどね。</p>
</section>
<section id="chap010406" class="level3">
<h4>組み込みクラスライブラリ</h4>
<p class="in">構文木インタプリタはプログラムの解釈実行を行いますが、実際の処理の多くの部分はクラスライブラリで提供されるメソッドによって実行されます。</p>
<p class="in">組み込みクラスライブラリのメソッドはCで記述されています。ですからインタプリタの負荷と関係なくコンパイルされた速度で実行されます。インタプリタによる解釈・実行がコンパイラ型言語による実行の1000倍遅くても（マシン語の命令数で比較するなら最低でもそれくらいは違う）、全体の実行速度がそれほどまでは差がつかないのは、これらの組み込みメソッドが同等の速度で動作しているからです。</p>
<p class="in">しかも、組み込みクラスライブラリはデータ構造、アルゴリズムともに時間と手間をかけて実装されていますから、インタプリタの負荷を除けば、下手なCプログラムよりもはるかに高速に動作していることになります。</p>
</section>
<section id="chap010407" class="level3">
<h4>文字列/配列/ハッシュ</h4>
<p class="in">文字列、配列、ハッシュはRubyにおける基本的なデータ型です。これらのデータ構造に対する処理の種類はPerlを参考に決められています。長い経験のあるPerlでの処理を参考にしたうえで、クラスという単位で機能を分類することにより、使いやすいクラスライブラリを実現しています。</p>
<p class="in">これらのデータに対するメソッドは多少実装に手間がかかっても高速なものを選択しています。これらのメソッドはあらゆる局面で繰り返し使われるので、手間をかけることが報われるからです。</p>
<p class="in">その他のこれらデータ構造における効率上の工夫といえば、たとえば文字列におけるコピー・オン・ライト（copy on write）をあげることができます。</p>
<p class="in">Rubyにおいて文字列は参照されるたびに新しく生成されます。これは文字列の内容を変更しても、元の文字列を保存するためですが（<a href="#list0102">リスト1.2</a>）、文字列は非常に多用されますから、参照されるたびに毎回メモリ領域を割り当てて、文字列の内容をコピーしていたのでは効率が悪すぎます。そこで、新しい文字列オブジェクトを生成したあと、文字列の内容を共有することにします。変更が行われるときに初めてメモリ領域の割り当てと内容のコピーを行うわけです。</p>
<a id="page_017"/>
<div class="plistc" id="list0102">
<p class="lst-caption">リスト1.2●文字列の参照</p>
<pre><span class="kwd">def</span> foo
  <span class="str">&quot;abc&quot;</span>
<span class="kwd">end</span>

a = foo()
a[0] = <span class="str">&quot;b&quot;</span>
print a, <span class="str">&quot;\n&quot;</span>       <span class="cmt"># =&gt; &quot;bbc&quot;</span>

print foo(), <span class="str">&quot;\n&quot;</span>   <span class="cmt"># =&gt; &quot;abc&quot;のままであってほしい</span></pre>
<hr class="hr-gray" />
</div>
<p class="in">この方法によって無駄なコピーをかなりの割合で削減できています。</p>
</section>
<section id="chap010408" class="level3">
<h4>数値計算</h4>
<p class="in">コンピュータはもともとは電子計算機と呼ばれていたくらいですから、本来は計算が得意です。Rubyは実行効率の観点から数値処理を高速に行うよりも、むしろ文字列を操作することなどのスクリプト向きの仕事のほうが得意なのですが、それでも数字を取り扱うことはしばしばあります。</p>
<p class="in">特に整数は非常に頻繁に登場するので、整数オブジェクトの取り扱いは効率に大きく影響します。そこでRubyではいくつかのオブジェクトにはメモリ領域を割り当てず、変数の中に直接格納するようにしています。このように直接変数の中に格納されるオブジェクトは小さな（31ビット幅程度の）整数<code>Fixnum</code>と<code>nil</code>, <code>true</code>, <code>false</code>です。</p>
<p class="in"><code>Fixnum</code>の場合、変数（Cレベルで見るとポインタ）の内容の1ビット目（LSB）が1ならば、その変数の中身は参照ではなく、<code>Fixnum</code>の値が格納されているものとします。変数の中に格納された<code>Fixnum</code>から整数を取り出すには全体を1ビット右シフトさせます。</p>
<p class="in">この手法により、整数の操作に伴うオブジェクトの生成を避けることが可能になっています。また、<code>Fixnum</code>と整数のやりとりは単純なシフト演算によって行われますから、これも高速に処理できます。</p>
<p class="in">一方、Pythonでは整数処理の高速化に対して別のアプローチを取っています。Pythonの作者は変数の中に埋め込む特殊なオブジェクトの存在を嫌って、整数もすべて「普通のオブジェクト」にすることにしました。しかし、整数1つ1つに毎回オブジェクトを生成するのは効率上つらい面もあるので、以下の工夫を行っています。</p>
<ul>
<li><p>整数オブジェクト専用の割り当てルーチンを用意して、オブジェクトをできるだけ再利用する</p></li>
<li><p>−1〜100までの範囲の整数はあらかじめ生成してテーブルに登録しておく</p></li>
</ul>
<p class="in">Pythonについて正確な統計を取ったことはありませんが、これらの工夫もかなりの効果をあげているようです。</p>
</section>
<section id="chap010409" class="level3">
<a id="page_018"/>
<h4>Bignum <span class="emdash">――</span> 無限多倍長整数</h4>
<p class="in">Rubyでは<code>Fixnum</code>で表現される小さな整数の他に<code>Bignum</code>と呼ばれる多倍長演算を行うクラスがあります。このクラスのおかげでたとえば400の階乗のような非常に大きな数も（効率を気にしなければ）自由に計算できます。</p>
<p class="in">もともとRubyに<code>Bignum</code>を導入した動機というのが、<code>Fixnum</code>の範囲に収まらない整数を取り扱いたかったという単純なもので「単純なニーズの割に大げさなものを導入してしまったなあ」というのが正直な感想です。しかし、「まあ、便利だからいいか」と思っているのも事実です。</p>
<p class="in"><code>Bignum</code>はその値を<code>short</code>（多くは16ビット）の配列として格納しています。計算は単純に繰り上がり、繰り下がりを考慮しつつ<code>short</code>を対象に行います。ただ、割算だけは簡単なアルゴリズムがなく、自分でも十分に理解しきれない手順に悩まされました。</p>
<p class="in">Rubyの整数は計算結果が<code>Fixnum</code>で表現できるときには<code>Fixnum</code>を、その範囲を超えるときは自動的に<code>Bignum</code>を返します。ですから、プログラミングのレベルでは、ほとんどの場合大きさの限界を意識することなく整数を取り扱うことができます。</p>
</section>
<section id="chap010410" class="level3">
<h4>正規表現</h4>
<p class="in">正規表現とは文字列のパターンの表現方法です。Rubyを始めとするスクリプト言語は正規表現がしばしば重要な役割を果たします。</p>
<p class="in">Rubyの正規表現ルーチンは、もともとEmacsのために開発され、gawkで用いられていたものがベースになっています。このルーチンを採用した理由は、</p>
<ul>
<li><p>フリー（GPL, 現在はLGPL）</p></li>
<li><p>パターン、文字列に <code>\0</code>を含むことができる</p></li>
<li><p>8ビットクリーン</p></li>
<li><p>日本語化パッチ（EUC, SJIS）が入手できた</p></li>
</ul>
<p class="ni">というものです。その後、Rubyで使うために以下のかなり大規模な改造を行っています。</p>
<div class="description">
<p class="ditem">Perl正規表現の追加</p>
<p class="dni">Perlで追加された拡張正規表現に対応しています。Perlの正規表現はどんどん追加されるので少々息切れしています。</p>
<p class="ditem">Emacs固有ルーチンの削除</p>
<p class="dni">Rubyでは利用しない機能をいくつか削除しています。具体的には正規表現の文法の切り替え、syntax tableのサポート、ポイントのサポート、それからメタ文字の <code>&lt;</code>, <code>&gt;</code> です。</p>
<p class="ditem">バグ修正</p>
<p class="dni">正規表現ルーチンに残っていたバグを2つほど修正してあります。</p>
<p class="ditem">UTF-8対応</p>
<p class="dni">入手した日本語化パッチはEUCとSJISにしか対応していませんでしたが、吉田正人さんがXML対応の一貫としてUTF-8にも対応させてくださいました。</p>
<a id="page_019"/>
<p class="ditem">最適化</p>
<p class="dni">もともとのEmacsの正規表現ルーチンは、後述のfastmapと呼ばれる手法しか高速化のための工夫を行っていませんでしたが、Perlなどを参考にいくつか最適化を加えています。</p>
</div>
<p class="in">さて、すでに述べたように正規表現はスクリプト言語ではしばしば多用されますから、正規表現ルーチンの高速化は処理全体の実行効率に関わってきます。Rubyの利用している正規表現ルーチンは以下の最適化を行っています。</p>
<div class="description">
<p class="ditem">fastmap（Emacsからある）</p>
<p class="dni">パターンの先頭にマッチし得る文字のテーブルをあらかじめ計算しておき、マッチ対象の文字列からマッチし得る部分を素早く検索するために使われます。</p>
<p class="ditem">固定文字列による絞り込み</p>
<p class="dni">正規表現が<code>ruby</code>という文字列を必ず含む場合、その文字列を含まない文字列は最初から検索対象になりません。あらかじめ必ずマッチする文字列を計算して、BMサーチという高速文字列検索アルゴリズムを使ってマッチ処理の前に絞り込みを行っています。</p>
<p class="ditem">その他</p>
<p class="dni">たとえば、正規表現の先頭が <code>.*</code> であった場合、先頭でマッチが失敗すれば、そのあとのチェックは不要であるとか、細々とした最適化を行っています。</p>
</div>
<p class="in">なお、これらの正規表現の最適化は『詳説 正規表現』という書籍からの情報を参考にしています。</p>
<p class="in">実装者の観点からいうと、正規表現は非常に奥が深く、面白く、かつつらい分野です。特にRubyの正規表現ルーチンはもともと自分で書いたものではないうえに、原形をとどめないほどの改造を行っているので、バグが出ると悲しくなってしまいます。</p>
</section>
<section id="chap010411" class="level3">
<h4>スレッド</h4>
<p class="in">Rubyには1つのプログラムの中で複数の制御の流れが存在するスレッド機能を持っていて、これが言語の特徴の1つになっています。</p>
<p class="in">スレッド機能の実装には、OSの協力を必要とするカーネルレベルスレッドと、プログラムが全部自前で実装するユーザーレベルスレッドがあります。</p>
<p class="in">カーネルレベルスレッドはOSの協力を受けるので、マルチCPUの活用ができる一方、OSがスレッド機能に対応してくれなければ使えないという問題があります。最近のUNIXの多くや、NTなどでは使えますが、DOSなど古いOSでは使えないということです。</p>
<p class="in">ユーザーレベルスレッドはスレッドの切り替えなどを全部自前で実現しますから、カーネルレベルスレッドのようなマルチCPUの活用などは不可能です。その代わりOSに依存しない移植性の高い実装が可能です。</p>
<p class="in">Rubyはユーザーレベルスレッドを採用しています。最大の理由はDOSやMacのような古いOSや、カーネルレベルスレッドを採用していないUNIX系OSでも同様のスレッドの使い勝手を提供するためです。残念ながらカーネルレベルスレッドはどこででも使えるわけではありませんし、たとえ使えたとしても各OSごとに仕様や挙動が違うというのが現実ですから。</p>
<a id="page_020"/>
<p class="in">RubyのスレッドはRubyが動くところならどこでも同じように動作します。DOSでスレッドプログラミングを気軽にできるのは、ある意味感動ものでもあります。</p>
<p class="in">Rubyのスレッドはユーザーレベルスレッドですから、マルチCPUを活用できませんし、スレッドの制御の切り替えのコストがありますから、全体の実行時間は決して短くなりません。また、後述する理由により制御の切り替えのコストもあまり軽くはありません。</p>
</section>
<section id="chap010412" class="level3">
<h4>スレッドの実装</h4>
<p class="in">では、Rubyがスレッドをどのように実装しているかを簡単に解説しましょう。詳細はRubyのソースコードを見てください。</p>
<p class="in">プログラムの実行状態は大まかにいうと、大域変数とスタック（関数の呼び出し階層とローカル変数）とレジスタ（ローカル関数、作業領域）に格納されています。スレッドの場合、大域変数は共有しますから、スタックとレジスタの状態を保存して、切り替えることができればよいということになります。</p>
<p class="in">Cには<code>setjmp</code>/<code>longjmp</code>という関数があってレジスタなどの状態を<code>jmp_buf</code>という構造体に書き出す機能があります。この<code>jmp_buf</code>はコンサバティブGCにも使われていましたね。スレッドの実装にもこの機能を利用します。</p>
<p class="in">Rubyでは以下の手順でスレッドを切り替えます。</p>
<ol class="list_parentheses">
<li><code>setjmp()</code>を使って、現在のレジスタなどの状態を<code>jmp_buf</code>に書き出します。この保存された状態は現在スレッドに制御を返すときに使われます</li>
<li>現在のスタックの状態をヒープにコピーします</li>
<li>切り替え先のスレッドが保存しているスタック状態をスタックに書き戻します</li>
<li>切り替え先のスレッドに保存してあった<code>jmp_buf</code>を使って<code>longjmp()</code>します。するとアラ不思議、<code>setjmp()</code>でセーブした時点から実行を再開します</li>
</ol>
<p class="ni">ここで(2)や(3)の手順でローカル変数が使えないことに注意してください。スタックを壊してしまいます。関数呼び出しも使えません。</p>
<p class="in">この方式だとスレッドの切り替えのたびにスタック領域のコピーと書き戻しが発生するので正直なところ効率はあまりよくありません。他のユーザーレベルスレッドの実装の中ではスタック領域をあらかじめ固定領域に割り当てることで、このコピーを行わない実装もあります。しかし、そのような実装には以下のデメリットがあります。</p>
<ul>
<li><p>スタック領域を割り当てるためにはCPUのスタックポインタを書き換える必要があるが、移植性のある方法では実現できない。OS, CPUごとに対応する必要がある</p></li>
<li><p>あらかじめ割り当てられたスタック領域の大きさを拡張できない。この領域を超えるとインタプリタ全体が異常終了する</p></li>
</ul>
<p class="in">これらのデメリットはRubyのポリシーから考えるといずれも致命的に思えます。そこでRubyでは少々効率が悪くてもコピーする方法を採用しました。</p>
<a id="page_021"/>
<p class="in">このようにRubyのスレッド機能の実装は効率よりもむしろ安全性や移植性に重点を置いて設計されています。</p>
<p class="in">スレッドを使うと実行時間の総計はスレッド切り替えのコストでかえって長くなるということですし、プログラムの性能向上には貢献しないように思えます。</p>
<p class="in">しかし、全体の処理時間は短縮しなくても、時間のかかる処理をスレッドに任せてバックグラウンドで実行することにより、プログラムの応答性が改善するなどのメリットはあります。</p>
<p class="in">Rubyではどこでも動くスレッドがあるので安心してスレッドが使えるという点も見過ごしにできません。</p>
</section>
<section id="chap010413" class="level3">
<h4>拡張ライブラリ</h4>
<p class="in">さて、ここまででRuby言語の処理系の基本的な部分について簡単に見てきました。Rubyインタプリタはプログラミングに便利なたくさんの機能を組み込みで持っていますが、あらゆる機能を提供しているわけではありません。そんなことは原理的に不可能です。</p>
<p class="in">しかし、Rubyには拡張ライブラリという形でインタプリタにあとから機能を追加することができるようになっています。しかも、多くのOSではインタプリタそのものを再コンパイルあるいは再リンクする必要なしに実行時にロードすることができます。</p>
<p class="in">実際にネットワークソケット機能やデータベースアクセス機能などが拡張ライブラリとして提供されています。</p>
<p class="in">拡張ライブラリはRubyインタプリタに機能を追加するためにも使われますが、実はプログラムの実行効率向上のためにも使うことができます。実行のボトルネックになる部分をCで記述したメソッドとして拡張ライブラリ化してしまうことで、処理の重い部分はCで高速に、それ以外の部分はRubyで快適にプログラミングすることが可能になるのです。これこそ適材適所ですね。</p>
<p class="in">このような拡張ライブラリと、その動的ロードの機能はRubyのライバルであるPerlやPythonでももちろん提供されています。これらの拡張ライブラリと比較した場合、Rubyのほうには以下の利点があります。</p>
<ul>
<li><p><span class="k">コンサバティブGCによりオブジェクトの参照数の管理が不要</span><br />
他言語ではリファレンスカウントを採用しているのでオブジェクトの参照数を管理する必要があります。これを忘れると面倒なバグの原因になります。</p></li>
<li><p><span class="k">Rubyでできることをほぼストレートに記述できる高レベルなAPI</span><br />
CとRubyの言語の差による必然的な違い以外には、クラス定義、メソッド定義などについてほぼ同様の機能を提供するC言語用APIを用意しています。当り前のことのようですが、他言語ではCからのオブジェクトの操作などに制限があり、基本的な部分だけCで記述し、その外側にスクリプト言語で皮をかぶせるような方法がよく取られます。Rubyではそのような方法が必要になることはほとんどありません。</p></li>
</ul>
<p class="in">実はまだまだ拡張ライブラリの資産の蓄積という点でライバルたちに負けているのですが、今後ユーザーの増加とともに追いつきたいと考えています。その場合にはこの「拡張ライブラリの書きやすさ」が武器になるはずです。</p>
</section>
</section>
<section id="chap0105" class="level2">
<a id="page_022"/>
<h3>まとめ</h3>
<hr class="hr-gray" />
<p class="in">本稿ではRuby言語の実装とそこに使われている手法を特に実行効率の向上という点を中心に解説しました。しかし、Rubyはソースコードの規模が5万行を超えるかなり大規模なソフトウェアですから、ここでは簡単にしか説明できなかったことばかりです。</p>
<p class="in">興味のある人は実際にRubyを入手し、使ってみて、あるいはソースコードを眺めてみてください。Rubyは入手も利用も無料です。そして、できればプログラミング言語の実装の楽しみに目覚めていただければと願っています。</p>
<p class="in">Happy Hacking!</p>
<section id="chap010501" class="level3">
<h4>参考文献</h4>
<p class="ni"><span class="k">書籍:</span></p>
<p class="ni">『オブジェクト指向スクリプト言語Ruby（仮題）』, まつもと ゆきひろ・石塚圭樹共著, アスキー（近刊）</p>
<p class="ni">『詳説 正規表現』, Jeffrey E.F. Friedl著, オライリー・ジャパン</p>
<p><br /></p>
<p class="ni"><span class="k">URL:</span></p>
<p class="ni"><span class="link">http://www.netlab.co.jp/ruby/jp/</span></p>
<p class="i2w">Rubyホームページ。Rubyに関することなら何でもここから参照できる（はず）。</p>
<p class="ni"><span class="link">http://ruby.freak.ne.jp/</span></p>
<p class="i2w">Unofficial Ruby Home Page。本家Rubyホームページよりもはるかに出来がよい。<br />
メーリングリストのトピックのまとめが秀逸。</p>
<p class="ni"><span class="link">http://www.jin.gr.jp/~nahi/link-Ruby.html</span></p>
<p class="i2w">Linkavailable: Ruby。Ruby関連のページの更新状況がひと目でわかる。</p>
<p class="ni"><span class="link">http://cuiwww.unige.ch/langlist</span></p>
<p class="i2w">The Language List（英語）。古今東西のコンピュータ言語に関する情報が集められている。ここにはRubyは登録されておらず、Rubyという名の別の言語（ハードウェア記述言語）が登録されている。</p>
<p class="ni"><span class="link">http://www.iecc.com/gclist/GC-faq.html</span></p>
<p class="i2w">GC FAQ（英語）。ガベージコレクションに関する「よくある質問とその答」集。歴史的な事情からGCはよく誤解されている（遅い、重い、使えないとか）ので、その誤解に対する答を提供している。</p>
</section>
</section>
</section>
<!-- Navigation -->
<br /><br />
<hr />
<p class="navigation-right"><a href="p-001.xhtml">&lt;&lt; 前ページ</a>　<a href="p-003.xhtml">次ページ &gt;&gt;</a></p>
</body>
</html>
