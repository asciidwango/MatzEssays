<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html
 xmlns="http://www.w3.org/1999/xhtml"
 xmlns:epub="http://www.idpf.org/2007/ops"
 xml:lang="ja"
 class="hltr"
>
<head>
<meta charset="UTF-8"/>
<title>第53章 言語の重要性</title>
<link rel="stylesheet" type="text/css" href="../../style/book-style.css"/>
</head>
<body epub:type="bodymatter">
<!-- Navigation -->
<h1>Matz Essays Volume 2</h1>
<p class="navigation-top"><a href="../../index.xhtml">HOME</a>　&gt;　<a href="../index.xhtml">Volume 2</a>　&gt;　第53章</p>
<!-- Body -->
<section id="chap53" class="level1">
<a id="page_219"/>
<span class="chap-title">Matz Essay</span><span class="chap-num">53</span>
<hr class="chap-hr" />
<h2>
<span class="fontsmall">まつもと ゆきひろのハッカーズライフ</span><br />
言語の重要性
</h2>
<hr class="chap-hr" />
<p class="right">[<span class="it">UNIX USER</span>, 2005年9月号]</p>
<div class="newlead">
<p class="in">言語オタクとしてプログラミング言語の重要性について語っています。言語には、思考の手段、記述の手段、読む手段、そして実行する手段としての側面があり、それぞれに重要であると述べています。プログラムを開発する人は例外なく何らかのプログラミング言語を学ぶわけですが、その言語は記述の手段と実行の手段としてしか捉えていない人が多いでしょう。しかし、あまり注目されない思考の手段としての言語、また読む手段としての言語も重要です。思考の手段としての言語は、人間がプログラミング的に思考することを支援してくれますし、ある種のパラダイムを強調する言語では、「問題の捉え方」そのものが変化してしまうかもしれません。また、プログラミングを学ぶ最良の方法は他人の書いたプログラムを読んで考えることであり、そのためにも読む手段としての言語は重要です。これは時代が変わっても変化しない真理だと思います。</p>
</div>
<section id="chap5301" class="level2">
<h3>言語へのこだわり</h3>
<hr class="hr-gray" />
<p class="in">ハッカーは、プログラミング言語にこだわる人がとても多いことが知られています。たとえば『ハッカーと画家』<a href="#fn1" class="footnote-ref" id="fnref1" epub:type="noteref" role="doc-noteref">1</a> などの著書で知られるPaul Graham<a href="#fn2" class="footnote-ref" id="fnref2" epub:type="noteref" role="doc-noteref">2</a> はLispに大変こだわっており、著書やエッセイの中でLispのパワーについてたびたび熱く語っています。私自身もプログラミング言語に深いこだわりを持つハッカーであり、自ら「言語おたく」を自称しています。私以外にもプログラミング言語好きのハッカーは数多く、中にはそれを本職にしてしまっている「言語屋」と呼ばれる人たちも存在するほどです。</p>
<a id="page_220"/>
<p class="in">では、なぜハッカーはそんなにも言語にこだわるのでしょうか。それはおそらく、プログラミング言語がハッカーの力と密接な関係があることだと思います。前回、プログラミングがハッカーの力の源であると述べました。そして、そのプログラミングが言語を通じて行われる以上、言語はハッカー最強の道具です。ですから、どのような言語をどのように使うかは、ハッカーの力の大きさに直接関係します。ハッカーは自分の能力や道具の良し悪しにとても敏感ですから、どうしても言語にこだわってしまうのでしょう。</p>
<p class="in">いわゆる「普通の人」には、この気持ちを理解することは難しいのかもしれません。普段あまりプログラムを書かない人にとって、どのような言語でプログラムを書こうとも、結局はアルゴリズムを記述しているのであり、その本質は大差ないと感じることでしょう。確かにチューリング完全<a href="#fn3" class="footnote-ref" id="fnref3" epub:type="noteref" role="doc-noteref">3</a> な言語であれば、任意のアルゴリズムを記述可能だそうですから、数学的には（ある一定の条件を満たす）すべての言語は等価なのかもしれません。しかし、現実にはすべての言語は等価ではないのです。</p>
</section>
<section id="chap5302" class="level2">
<h3>思考表現の手段としての言語</h3>
<hr class="hr-gray" />
<p class="in">たとえ理論的には同じアルゴリズムを記述したとしても、言語が違えばその表現は大きく異なります。そして、その表現の違いが言語の違いを生むのです。プログラミング言語というものは、プログラムというコンピュータに対する仕事の手順を記述するものですから、その対象はコンピュータであると考えがちです。しかし、実際には言語によって影響を受けるのは人間のほうです。言語は人間の思考をコンピュータにも理解できる形で表現する手段なわけですが、思考の道具でもあるのです。</p>
<p class="in">自然言語学には「人が話す言葉と、人の物事の理解の仕方や振る舞い方には密接な関係があるのではないか」という「Sapir-Whorf仮説」というものがあります。私自身も日本語で話しているときと英語で話しているときで性格が違うような気がする<a href="#fn4" class="footnote-ref" id="fnref4" epub:type="noteref" role="doc-noteref">4</a> ので、個人的な経験からはこの仮説は成立していそうなのですが、実際にこれが正しいことを示す学術的な証拠は見つかっておらず、どっちかっていうと否定されているっぽい仮説です。しかし、自然言語についてこの仮説が正しいかどうかにかかわらず、使用するプログラミング言語によってプログラマーの発想が影響を受けるのは事実です。</p>
<p class="in">私がBASICユーザーだった中学生の頃、関数が自分自身を呼び出す再帰という考え方が理解できず、3日間Pascalの教科書とにらめっこした覚えがあります。まあ、実際に手元にPascalの処理系があって実行することができればもっと早く理解できたのかもしれませんが、当時は自分で自由に使えるコンピュータを（BASICポケコン以外は）所有していませんでしたから。もし私が最初に使った言語がLispだったりしたら、おそらく再帰という考え方に違和感を覚えることはなかったでしょう。</p>
<p class="in">このことから、「より強力な言語を使うことはプログラマーがよりよい発想を持つ助けになる」ということがわかります。言語の選択はプログラマーの能力に影響を与えるのです。また、一度学んだ発想は他の言語を使うときにも応用しやすいので、新しい言語を学ぶということはより優秀なプログラマーへの近道でもあります。名著として知られる『達人プログラマー』<a href="#fn5" class="footnote-ref" id="fnref5" epub:type="noteref" role="doc-noteref">5</a> の中で著者たちは「1年に1つ新しい言語を覚える」というチャレンジを提案しています。これも同じ理由からです。実は彼らはこの本を書いた直後にこのチャレンジを自ら実践してRubyを発見し、あまりに気に入ったので英語圏における初のRuby解説書である『プログラミングRuby』<a href="#fn6" class="footnote-ref" id="fnref6" epub:type="noteref" role="doc-noteref">6</a> を書いたのでした。</p>
</section>
<section id="chap5303" class="level2">
<a id="page_221"/>
<h3>プログラムを書く手段としての言語</h3>
<hr class="hr-gray" />
<p class="in">このように言語は考えることも助けてくれますが、考えるだけではプログラムは完成しません。やはり言語の一番重要な側面はプログラムを書くことです。</p>
<p class="in">さて、名著『人月の神話』<a href="#fn7" class="footnote-ref" id="fnref7" epub:type="noteref" role="doc-noteref">7</a> によれば「基本的な1ステートメントを製造するに要する工数は言語によらずほぼ一定」なのだそうです。とすれば、同じ処理を記述するときに言語Aで1000行、言語Bで10行必要であったとすれば、言語Bを採用するだけで生産性がおよそ100倍になるということになります。「そんなバカな」と思うかもしれませんが、たとえばJavaとRubyで同じ処理を記述する場合、ステートメント数で2倍以上の差がつくことは珍しくありません。アセンブラとRubyだったら100倍どころか1000倍の差がつくケースもありそうです。プログラミング言語進化の歴史は「いかにより簡潔な記述を可能にするか」を探し求めてきた歴史でもあります。</p>
<p class="in">また、言語の差よりも重大なのはライブラリがそろっているかどうかです。たとえばネットワーク経由でHTTPアクセスをしたい場合、ソケットを用いてネットワークコネクションを確立する処理から書き始めれば、どんな言語を使っても500行以下で実現できるとは思えません。しかし、HTTPを直接扱うことのできるライブラリがあればHTTPアクセスそのものがたった1行で実現できるかもしれません。この差は大変重要です。</p>
</section>
<section id="chap5304" class="level2">
<h3>プログラムを読む手段としての言語</h3>
<hr class="hr-gray" />
<p class="in">ほとんどの場合、プログラミングとは一度プログラムを書いてそれで終わりというわけにはいきません。バグがあればプログラムを読み返して、本当に正しい記述が行われているか確認しなければなりませんし、他の人が書いたプログラムを読んで保守しなければならないこともたびたびです。また、半年も経てば自分が書いたプログラムでも他人が書いたものと同じです。読んでみないと、何をしようとしていたのかわからないものです。とすると、もしかするとプログラムを書く時間よりもプログラムを読む時間のほうが長いかもしれません。</p>
<a id="page_222"/>
<p class="in">一般に、書きやすい言語によって書かれた簡潔なプログラムは、無駄な「お約束」が少なく、処理の本質に集中できるので読みやすいことが多いのですが、プログラムの簡潔さと読みやすさがいつも比例するとは限りません。簡潔すぎて情報量が少ないプログラムは読解のために推測すべきことが多くなり、かえって読みにくいこともあります。たとえば、書くときには面倒なだけの型情報は、読むときにはずいぶん役に立ちます。また、記号などを使って「圧縮」されたプログラムは短くても超難解です。「write-only language」とか「executable line noise」などと悪口をいわれるプログラム言語もあります。特に名前を出しませんが（笑）。</p>
</section>
<section id="chap5305" class="level2">
<h3>プログラム実行系としての言語</h3>
<hr class="hr-gray" />
<p class="in">異なる言語で、同じアルゴリズムを使って同じようにプログラムを書いたとしても、同じような速度で実行できるとは限りません。プログラミング言語は、その実行形式（コンパイラ型かインタプリタ型か）や処理系の優劣によって実行性能が大きく変動するからです。ハッカーの中にはスピード命というタイプもいますし、最終的なプログラムの実行性能を重要視する人も多いです。一般に柔軟で生産性の高い言語は、実行時に行うことが多くて、実行性能が低い傾向があります。開発時の生産性か実行時の性能か。なかなか難しいトレードオフです。</p>
<p class="in">ああっ、もう誌面が尽きてしまいました。言語おたくが言語について語り出すと止まりません。来月もこの続きを語ることにしましょう。</p>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" epub:type="footnotes">
<hr />
<ol>
<li epub:type="footnote" id="fn1">
<p><span class="k">『ハッカーと画家』</span></p>
<p>Paul Graham著、川合史郎訳『ハッカーと画家 コンピュータ時代の創造者たち』オーム社（ISBN4-27406-597-9）。ハッカーの生態をわかりやすく描いた書籍として知られている。全16章中、実に4章が言語を主題にしており、さらに多くの章がハッカーと言語の関係について語っている。ハッカーについて理解したい人にとって必読書。ハッカーにとっては前半は当り前すぎて退屈かも。
<a href="#fnref1" class="footnote-back" role="doc-backlink">↑</a></p>
</li>
<li epub:type="footnote" id="fn2">
<p><span class="k">Paul Graham</span></p>
<p>『ハッカーと画家』の著者。ベンチャー企業Viaweb（現Yahoo!Store）を成功させたリッチなハッカー。Viawebの成功の秘密は、Lispを使った生産性にあったそうだ。ハッカーでもリッチになれるという希望の星。しかし、彼の名を本当に高めているのはViawebの成功ではなく、彼の書くハッカーの生態を描き出したエッセイである。『ハッカーと画家』に未収録のものも多いが、そのいくつかは川合史朗さんによって翻訳されている。<br />
<span class="link">http://www.shiro.dreamhost.com/scheme/index-j.html</span>
<a href="#fnref2" class="footnote-back" role="doc-backlink">↑</a></p>
</li>
<li epub:type="footnote" id="fn3">
<p><span class="k">チューリング完全</span></p>
<p>Alan Turingがアルゴリズムを記述するために考案した仮想的な機械チューリングマシンを表現できる言語のクラス。チューリング完全な言語は停止可能な任意のアルゴリズムを記述できるらしい。
<a href="#fnref3" class="footnote-back" role="doc-backlink">↑</a></p>
</li>
<li epub:type="footnote" id="fn4">
<p><span class="k">性格が違うような気がする</span></p>
<p>私自身は英語を使っているときのほうが論理的な思考をするような気がする。先日、英会話番組でソニンも同じようなことを言っていたから、そう感じるのは私だけではないらしい。
<a href="#fnref4" class="footnote-back" role="doc-backlink">↑</a></p>
</li>
<li epub:type="footnote" id="fn5">
<p><span class="k">『達人プログラマー』</span></p>
<p>Andrew Hunt, David Thomas著、村上雅章訳『達人プログラマー』ピアソン・エデュケーション（ISBN4-89471-274-1）。プログラマーとしての能力を向上させる基本的なルールについて解説した本。プログラマー必読の書だと思う。
<a href="#fnref5" class="footnote-back" role="doc-backlink">↑</a></p>
</li>
<li epub:type="footnote" id="fn6">
<p><span class="k">『プログラミングRuby』</span></p>
<p>Andrew Hunt, David Thomas著、田和勝訳、まつもとゆきひろ監訳『プログラミングRuby』ピアソン・エデュケーション（ISBN4-89471-453-1）。英語ではRuby 1.8対応の第2版が出版されている。第2版も邦訳が予定されている。
<a href="#fnref6" class="footnote-back" role="doc-backlink">↑</a></p>
</li>
<li epub:type="footnote" id="fn7">
<p><span class="k">『人月の神話』</span></p>
<p>Frederick Phillips Brooks Jr.著、滝沢徹/牧野祐子/富澤昇訳『人月の神話【新装版】』ピアソン・エデュケーション（4-89471-665-8）。なんか今月はピアソンの本ばっかりだな。原著は20年以上前に書かれたものだが、その本質は変わらない。
<a href="#fnref7" class="footnote-back" role="doc-backlink">↑</a></p>
</li>
</ol>
</section>
<!-- Navigation -->
<br /><br />
<hr />
<p class="navigation-right"><a href="p-039.xhtml">&lt;&lt; 前ページ</a>　<a href="p-041.xhtml">次ページ &gt;&gt;</a></p>
</body>
</html>
